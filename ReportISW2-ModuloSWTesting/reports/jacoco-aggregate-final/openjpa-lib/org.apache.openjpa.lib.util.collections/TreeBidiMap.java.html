<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>TreeBidiMap.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-lib</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.lib.util.collections</a> &gt; <span class="el_source">TreeBidiMap.java</span></div><h1>TreeBidiMap.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.openjpa.lib.util.collections;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.AbstractSet;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

/**
 * Red-Black tree-based implementation of BidiMap where all objects added
 * implement the &lt;code&gt;Comparable&lt;/code&gt; interface.
 * &lt;p&gt;
 * This class guarantees that the map will be in both ascending key order
 * and ascending value order, sorted according to the natural order for
 * the key's and value's classes.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This Map is intended for applications that need to be able to look
 * up a key-value pairing by either key or value, and need to do so
 * with equal efficiency.
 * &lt;/p&gt;
 * &lt;p&gt;
 * While that goal could be accomplished by taking a pair of TreeMaps
 * and redirecting requests to the appropriate TreeMap (e.g.,
 * containsKey would be directed to the TreeMap that maps values to
 * keys, containsValue would be directed to the TreeMap that maps keys
 * to values), there are problems with that implementation.
 * If the data contained in the TreeMaps is large, the cost of redundant
 * storage becomes significant. The {@link DualTreeBidiMap} and
 * {@link DualHashBidiMap} implementations use this approach.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This solution keeps minimizes the data storage by holding data only once.
 * The red-black algorithm is based on {@link java.util.TreeMap}, but has been modified
 * to simultaneously map a tree node by key and by value. This doubles the
 * cost of put operations (but so does using two TreeMaps), and nearly doubles
 * the cost of remove operations (there is a savings in that the lookup of the
 * node to be removed only has to be performed once). And since only one node
 * contains the key and value, storage is significantly less than that
 * required by two TreeMaps.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The Map.Entry instances returned by the appropriate methods will
 * not allow setValue() and will throw an
 * UnsupportedOperationException on attempts to call that method.
 * &lt;/p&gt;
 *
 * @param &lt;K&gt; the type of the keys in this map
 * @param &lt;V&gt; the type of the values in this map
 *
 * @since 3.0 (previously DoubleOrderedMap v2.0)
 */
public class TreeBidiMap&lt;K extends Comparable&lt;K&gt;, V extends Comparable&lt;V&gt;&gt;
    implements OrderedBidiMap&lt;K, V&gt;, Serializable {

<span class="nc" id="L77">    enum DataElement {</span>
<span class="nc" id="L78">        KEY(&quot;key&quot;), VALUE(&quot;value&quot;);</span>

        private final String description;

        /**
         * Create a new TreeBidiMap.DataElement.
         *
         * @param description  the description for the element
         */
<span class="nc" id="L87">        DataElement(final String description) {</span>
<span class="nc" id="L88">            this.description = description;</span>
<span class="nc" id="L89">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L93">            return description;</span>
        }
    }

    private static final long serialVersionUID = 721969328361807L;

    private transient Node&lt;K, V&gt;[] rootNode;
<span class="nc" id="L100">    private transient int nodeCount = 0;</span>
<span class="nc" id="L101">    private transient int modifications = 0;</span>
    private transient Set&lt;K&gt; keySet;
    private transient Set&lt;V&gt; valuesSet;
    private transient Set&lt;Entry&lt;K, V&gt;&gt; entrySet;
<span class="nc" id="L105">    private transient Inverse inverse = null;</span>

    //-----------------------------------------------------------------------
    /**
     * Constructs a new empty TreeBidiMap.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public TreeBidiMap() {
<span class="nc" id="L113">        super();</span>
<span class="nc" id="L114">        rootNode = new Node[2];</span>
<span class="nc" id="L115">    }</span>

    /**
     * Constructs a new TreeBidiMap by copying an existing Map.
     *
     * @param map  the map to copy
     * @throws ClassCastException if the keys/values in the map are
     *  not Comparable or are not mutually comparable
     * @throws NullPointerException if any key or value in the map is null
     */
    public TreeBidiMap(final Map&lt;? extends K, ? extends V&gt; map) {
<span class="nc" id="L126">        this();</span>
<span class="nc" id="L127">        putAll(map);</span>
<span class="nc" id="L128">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Returns the number of key-value mappings in this map.
     *
     * @return the number of key-value mappings in this map
     */
    @Override
    public int size() {
<span class="nc" id="L138">        return nodeCount;</span>
    }

    /**
     * Checks whether the map is empty or not.
     *
     * @return true if the map is empty
     */
    @Override
    public boolean isEmpty() {
<span class="nc bnc" id="L148" title="All 2 branches missed.">        return nodeCount == 0;</span>
    }

    /**
     * Checks whether this map contains the a mapping for the specified key.
     * &lt;p&gt;
     * The key must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param key  key whose presence in this map is to be tested
     * @return true if this map contains a mapping for the specified key
     * @throws ClassCastException if the key is of an inappropriate type
     * @throws NullPointerException if the key is null
     */
    @Override
    public boolean containsKey(final Object key) {
<span class="nc" id="L163">        checkKey(key);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        return lookupKey(key) != null;</span>
    }

    /**
     * Checks whether this map contains the a mapping for the specified value.
     * &lt;p&gt;
     * The value must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param value  value whose presence in this map is to be tested
     * @return true if this map contains a mapping for the specified value
     * @throws ClassCastException if the value is of an inappropriate type
     * @throws NullPointerException if the value is null
     */
    @Override
    public boolean containsValue(final Object value) {
<span class="nc" id="L179">        checkValue(value);</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        return lookupValue(value) != null;</span>
    }

    /**
     * Gets the value to which this map maps the specified key.
     * Returns null if the map contains no mapping for this key.
     * &lt;p&gt;
     * The key must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param key  key whose associated value is to be returned
     * @return the value to which this map maps the specified key,
     *  or null if the map contains no mapping for this key
     * @throws ClassCastException if the key is of an inappropriate type
     * @throws NullPointerException if the key is null
     */
    @Override
    public V get(final Object key) {
<span class="nc" id="L197">        checkKey(key);</span>
<span class="nc" id="L198">        final Node&lt;K, V&gt; node = lookupKey(key);</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        return node == null ? null : node.getValue();</span>
    }

    /**
     * Puts the key-value pair into the map, replacing any previous pair.
     * &lt;p&gt;
     * When adding a key-value pair, the value may already exist in the map
     * against a different key. That mapping is removed, to ensure that the
     * value only occurs once in the inverse map.
     * &lt;pre&gt;
     *  BidiMap map1 = new TreeBidiMap();
     *  map.put(&quot;A&quot;,&quot;B&quot;);  // contains A mapped to B, as per Map
     *  map.put(&quot;A&quot;,&quot;C&quot;);  // contains A mapped to C, as per Map
     *
     *  BidiMap map2 = new TreeBidiMap();
     *  map.put(&quot;A&quot;,&quot;B&quot;);  // contains A mapped to B, as per Map
     *  map.put(&quot;C&quot;,&quot;B&quot;);  // contains C mapped to B, key A is removed
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Both key and value must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param key  key with which the specified value is to be  associated
     * @param value  value to be associated with the specified key
     * @return the previous value for the key
     * @throws ClassCastException if the key is of an inappropriate type
     * @throws NullPointerException if the key is null
     */
    @Override
    public V put(final K key, final V value) {
<span class="nc" id="L228">        final V result = get(key);</span>
<span class="nc" id="L229">        doPut(key, value);</span>
<span class="nc" id="L230">        return result;</span>
    }

    /**
     * Puts all the mappings from the specified map into this map.
     * &lt;p&gt;
     * All keys and values must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param map  the map to copy from
     */
    @Override
    public void putAll(final Map&lt;? extends K, ? extends V&gt; map) {
<span class="nc bnc" id="L242" title="All 2 branches missed.">        for (final Entry&lt;? extends K, ? extends V&gt; e : map.entrySet()) {</span>
<span class="nc" id="L243">            put(e.getKey(), e.getValue());</span>
<span class="nc" id="L244">        }</span>
<span class="nc" id="L245">    }</span>

    /**
     * Removes the mapping for this key from this map if present.
     * &lt;p&gt;
     * The key must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param key  key whose mapping is to be removed from the map.
     * @return previous value associated with specified key,
     *  or null if there was no mapping for key.
     * @throws ClassCastException if the key is of an inappropriate type
     * @throws NullPointerException if the key is null
     */
    @Override
    public V remove(final Object key) {
<span class="nc" id="L260">        return doRemoveKey(key);</span>
    }

    /**
     * Removes all mappings from this map.
     */
    @Override
    public void clear() {
<span class="nc" id="L268">        modify();</span>

<span class="nc" id="L270">        nodeCount = 0;</span>
<span class="nc" id="L271">        rootNode[DataElement.KEY.ordinal()] = null;</span>
<span class="nc" id="L272">        rootNode[DataElement.VALUE.ordinal()] = null;</span>
<span class="nc" id="L273">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Returns the key to which this map maps the specified value.
     * Returns null if the map contains no mapping for this value.
     * &lt;p&gt;
     * The value must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param value  value whose associated key is to be returned.
     * @return the key to which this map maps the specified value,
     *  or null if the map contains no mapping for this value.
     * @throws ClassCastException if the value is of an inappropriate type
     * @throws NullPointerException if the value is null
     */
    @Override
    public K getKey(final Object value) {
<span class="nc" id="L290">        checkValue(value);</span>
<span class="nc" id="L291">        final Node&lt;K, V&gt; node = lookupValue(value);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        return node == null ? null : node.getKey();</span>
    }

    /**
     * Removes the mapping for this value from this map if present.
     * &lt;p&gt;
     * The value must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param value  value whose mapping is to be removed from the map
     * @return previous key associated with specified value,
     *  or null if there was no mapping for value.
     * @throws ClassCastException if the value is of an inappropriate type
     * @throws NullPointerException if the value is null
     */
    @Override
    public K removeValue(final Object value) {
<span class="nc" id="L308">        return doRemoveValue(value);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the first (lowest) key currently in this map.
     *
     * @return the first (lowest) key currently in this sorted map
     * @throws NoSuchElementException if this map is empty
     */
    @Override
    public K firstKey() {
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (nodeCount == 0) {</span>
<span class="nc" id="L321">            throw new NoSuchElementException(&quot;Map is empty&quot;);</span>
        }
<span class="nc" id="L323">        return leastNode(rootNode[DataElement.KEY.ordinal()], DataElement.KEY).getKey();</span>
    }

    /**
     * Gets the last (highest) key currently in this map.
     *
     * @return the last (highest) key currently in this sorted map
     * @throws NoSuchElementException if this map is empty
     */
    @Override
    public K lastKey() {
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (nodeCount == 0) {</span>
<span class="nc" id="L335">            throw new NoSuchElementException(&quot;Map is empty&quot;);</span>
        }
<span class="nc" id="L337">        return greatestNode(rootNode[DataElement.KEY.ordinal()], DataElement.KEY).getKey();</span>
    }

    /**
     * Gets the next key after the one specified.
     * &lt;p&gt;
     * The key must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param key the key to search for next from
     * @return the next key, null if no match or at end
     */
    @Override
    public K nextKey(final K key) {
<span class="nc" id="L350">        checkKey(key);</span>
<span class="nc" id="L351">        final Node&lt;K, V&gt; node = nextGreater(lookupKey(key), DataElement.KEY);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">        return node == null ? null : node.getKey();</span>
    }

    /**
     * Gets the previous key before the one specified.
     * &lt;p&gt;
     * The key must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param key the key to search for previous from
     * @return the previous key, null if no match or at start
     */
    @Override
    public K previousKey(final K key) {
<span class="nc" id="L365">        checkKey(key);</span>
<span class="nc" id="L366">        final Node&lt;K, V&gt; node = nextSmaller(lookupKey(key), DataElement.KEY);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        return node == null ? null : node.getKey();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a set view of the keys contained in this map in key order.
     * &lt;p&gt;
     * The set is backed by the map, so changes to the map are reflected in
     * the set, and vice-versa. If the map is modified while an iteration over
     * the set is in progress, the results of the iteration are undefined.
     * &lt;p&gt;
     * The set supports element removal, which removes the corresponding mapping
     * from the map. It does not support the add or addAll operations.
     *
     * @return a set view of the keys contained in this map.
     */
    @Override
    public Set&lt;K&gt; keySet() {
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (keySet == null) {</span>
<span class="nc" id="L386">            keySet = new KeyView(DataElement.KEY);</span>
        }
<span class="nc" id="L388">        return keySet;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a set view of the values contained in this map in key order.
     * The returned object can be cast to a Set.
     * &lt;p&gt;
     * The set is backed by the map, so changes to the map are reflected in
     * the set, and vice-versa. If the map is modified while an iteration over
     * the set is in progress, the results of the iteration are undefined.
     * &lt;p&gt;
     * The set supports element removal, which removes the corresponding mapping
     * from the map. It does not support the add or addAll operations.
     *
     * @return a set view of the values contained in this map.
     */
    @Override
    public Set&lt;V&gt; values() {
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (valuesSet == null) {</span>
<span class="nc" id="L408">            valuesSet = new ValueView(DataElement.KEY);</span>
        }
<span class="nc" id="L410">        return valuesSet;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a set view of the entries contained in this map in key order.
     * For simple iteration through the map, the MapIterator is quicker.
     * &lt;p&gt;
     * The set is backed by the map, so changes to the map are reflected in
     * the set, and vice-versa. If the map is modified while an iteration over
     * the set is in progress, the results of the iteration are undefined.
     * &lt;p&gt;
     * The set supports element removal, which removes the corresponding mapping
     * from the map. It does not support the add or addAll operations.
     * The returned MapEntry objects do not support setValue.
     *
     * @return a set view of the values contained in this map.
     */
    @Override
    public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (entrySet == null) {</span>
<span class="nc" id="L431">            entrySet = new EntryView();</span>
        }
<span class="nc" id="L433">        return entrySet;</span>
    }

    //-----------------------------------------------------------------------
    @Override
    public OrderedMapIterator&lt;K, V&gt; mapIterator() {
<span class="nc bnc" id="L439" title="All 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L440">            return EmptyOrderedMapIterator.&lt;K, V&gt;emptyOrderedMapIterator();</span>
        }
<span class="nc" id="L442">        return new ViewMapIterator(DataElement.KEY);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the inverse map for comparison.
     *
     * @return the inverse map
     */
    @Override
    public OrderedBidiMap&lt;V, K&gt; inverseBidiMap() {
<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (inverse == null) {</span>
<span class="nc" id="L454">            inverse = new Inverse();</span>
        }
<span class="nc" id="L456">        return inverse;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Compares for equals as per the API.
     *
     * @param obj  the object to compare to
     * @return true if equal
     */
    @Override
    public boolean equals(final Object obj) {
<span class="nc" id="L468">        return this.doEquals(obj, DataElement.KEY);</span>
    }

    /**
     * Gets the hash code value for this map as per the API.
     *
     * @return the hash code value for this map
     */
    @Override
    public int hashCode() {
<span class="nc" id="L478">        return this.doHashCode(DataElement.KEY);</span>
    }

    /**
     * Returns a string version of this Map in standard format.
     *
     * @return a standard format string version of the map
     */
    @Override
    public String toString() {
<span class="nc" id="L488">        return this.doToString(DataElement.KEY);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Put logic.
     *
     * @param key  the key, always the main map key
     * @param value  the value, always the main map value
     */
    private void doPut(final K key, final V value) {
<span class="nc" id="L499">        checkKeyAndValue(key, value);</span>

        // store previous and remove previous mappings
<span class="nc" id="L502">        doRemoveKey(key);</span>
<span class="nc" id="L503">        doRemoveValue(value);</span>

<span class="nc" id="L505">        Node&lt;K, V&gt; node = rootNode[DataElement.KEY.ordinal()];</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">        if (node == null) {</span>
            // map is empty
<span class="nc" id="L508">            final Node&lt;K, V&gt; root = new Node&lt;&gt;(key, value);</span>
<span class="nc" id="L509">            rootNode[DataElement.KEY.ordinal()] = root;</span>
<span class="nc" id="L510">            rootNode[DataElement.VALUE.ordinal()] = root;</span>
<span class="nc" id="L511">            grow();</span>

<span class="nc" id="L513">        } else {</span>
            // add new mapping
            while (true) {
<span class="nc" id="L516">                final int cmp = compare(key, node.getKey());</span>

<span class="nc bnc" id="L518" title="All 2 branches missed.">                if (cmp == 0) {</span>
                    // shouldn't happen
<span class="nc" id="L520">                    throw new IllegalArgumentException(&quot;Cannot store a duplicate key (\&quot;&quot; + key + &quot;\&quot;) in this Map&quot;);</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                } else if (cmp &lt; 0) {</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">                    if (node.getLeft(DataElement.KEY) != null) {</span>
<span class="nc" id="L523">                        node = node.getLeft(DataElement.KEY);</span>
                    } else {
<span class="nc" id="L525">                        final Node&lt;K, V&gt; newNode = new Node&lt;&gt;(key, value);</span>

<span class="nc" id="L527">                        insertValue(newNode);</span>
<span class="nc" id="L528">                        node.setLeft(newNode, DataElement.KEY);</span>
<span class="nc" id="L529">                        newNode.setParent(node, DataElement.KEY);</span>
<span class="nc" id="L530">                        doRedBlackInsert(newNode, DataElement.KEY);</span>
<span class="nc" id="L531">                        grow();</span>

<span class="nc" id="L533">                        break;</span>
                    }
                } else { // cmp &gt; 0
<span class="nc bnc" id="L536" title="All 2 branches missed.">                    if (node.getRight(DataElement.KEY) != null) {</span>
<span class="nc" id="L537">                        node = node.getRight(DataElement.KEY);</span>
                    } else {
<span class="nc" id="L539">                        final Node&lt;K, V&gt; newNode = new Node&lt;&gt;(key, value);</span>

<span class="nc" id="L541">                        insertValue(newNode);</span>
<span class="nc" id="L542">                        node.setRight(newNode, DataElement.KEY);</span>
<span class="nc" id="L543">                        newNode.setParent(node, DataElement.KEY);</span>
<span class="nc" id="L544">                        doRedBlackInsert(newNode, DataElement.KEY);</span>
<span class="nc" id="L545">                        grow();</span>

<span class="nc" id="L547">                        break;</span>
                    }
                }
<span class="nc" id="L550">            }</span>
        }
<span class="nc" id="L552">    }</span>

    private V doRemoveKey(final Object key) {
<span class="nc" id="L555">        final Node&lt;K, V&gt; node = lookupKey(key);</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (node == null) {</span>
<span class="nc" id="L557">            return null;</span>
        }
<span class="nc" id="L559">        doRedBlackDelete(node);</span>
<span class="nc" id="L560">        return node.getValue();</span>
    }

    private K doRemoveValue(final Object value) {
<span class="nc" id="L564">        final Node&lt;K, V&gt; node = lookupValue(value);</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (node == null) {</span>
<span class="nc" id="L566">            return null;</span>
        }
<span class="nc" id="L568">        doRedBlackDelete(node);</span>
<span class="nc" id="L569">        return node.getKey();</span>
    }

    /**
     * do the actual lookup of a piece of data
     *
     * @param data the key or value to be looked up
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     * @return the desired Node, or null if there is no mapping of the
     *         specified data
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;T extends Comparable&lt;T&gt;&gt; Node&lt;K, V&gt; lookup(final Object data, final DataElement dataElement) {
<span class="nc" id="L583">        Node&lt;K, V&gt; rval = null;</span>
<span class="nc" id="L584">        Node&lt;K, V&gt; node = rootNode[dataElement.ordinal()];</span>

<span class="nc bnc" id="L586" title="All 2 branches missed.">        while (node != null) {</span>
<span class="nc" id="L587">            final int cmp = compare((T) data, (T) node.getData(dataElement));</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">            if (cmp == 0) {</span>
<span class="nc" id="L589">                rval = node;</span>
<span class="nc" id="L590">                break;</span>
            }
<span class="nc bnc" id="L592" title="All 2 branches missed.">            node = cmp &lt; 0 ? node.getLeft(dataElement) : node.getRight(dataElement);</span>
<span class="nc" id="L593">        }</span>

<span class="nc" id="L595">        return rval;</span>
    }

    private Node&lt;K, V&gt; lookupKey(final Object key) {
<span class="nc" id="L599">        return this.&lt;K&gt;lookup(key, DataElement.KEY);</span>
    }

    private Node&lt;K, V&gt; lookupValue(final Object value) {
<span class="nc" id="L603">        return this.&lt;V&gt;lookup(value, DataElement.VALUE);</span>
    }

    /**
     * get the next larger node from the specified node
     *
     * @param node the node to be searched from
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     * @return the specified node
     */
    private Node&lt;K, V&gt; nextGreater(final Node&lt;K, V&gt; node, final DataElement dataElement) {
        Node&lt;K, V&gt; rval;
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (node == null) {</span>
<span class="nc" id="L617">            rval = null;</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">        } else if (node.getRight(dataElement) != null) {</span>
            // everything to the node's right is larger. The least of
            // the right node's descendants is the next larger node
<span class="nc" id="L621">            rval = leastNode(node.getRight(dataElement), dataElement);</span>
        } else {
            // traverse up our ancestry until we find an ancestor that
            // is null or one whose left child is our ancestor. If we
            // find a null, then this node IS the largest node in the
            // tree, and there is no greater node. Otherwise, we are
            // the largest node in the subtree on that ancestor's left
            // ... and that ancestor is the next greatest node
<span class="nc" id="L629">            Node&lt;K, V&gt; parent = node.getParent(dataElement);</span>
<span class="nc" id="L630">            Node&lt;K, V&gt; child = node;</span>

<span class="nc bnc" id="L632" title="All 4 branches missed.">            while (parent != null &amp;&amp; child == parent.getRight(dataElement)) {</span>
<span class="nc" id="L633">                child = parent;</span>
<span class="nc" id="L634">                parent = parent.getParent(dataElement);</span>
            }
<span class="nc" id="L636">            rval = parent;</span>
        }
<span class="nc" id="L638">        return rval;</span>
    }

    /**
     * get the next larger node from the specified node
     *
     * @param node the node to be searched from
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     * @return the specified node
     */
    private Node&lt;K, V&gt; nextSmaller(final Node&lt;K, V&gt; node, final DataElement dataElement) {
        Node&lt;K, V&gt; rval;
<span class="nc bnc" id="L651" title="All 2 branches missed.">        if (node == null) {</span>
<span class="nc" id="L652">            rval = null;</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">        } else if (node.getLeft(dataElement) != null) {</span>
            // everything to the node's left is smaller. The greatest of
            // the left node's descendants is the next smaller node
<span class="nc" id="L656">            rval = greatestNode(node.getLeft(dataElement), dataElement);</span>
        } else {
            // traverse up our ancestry until we find an ancestor that
            // is null or one whose right child is our ancestor. If we
            // find a null, then this node IS the largest node in the
            // tree, and there is no greater node. Otherwise, we are
            // the largest node in the subtree on that ancestor's right
            // ... and that ancestor is the next greatest node
<span class="nc" id="L664">            Node&lt;K, V&gt; parent = node.getParent(dataElement);</span>
<span class="nc" id="L665">            Node&lt;K, V&gt; child = node;</span>

<span class="nc bnc" id="L667" title="All 4 branches missed.">            while (parent != null &amp;&amp; child == parent.getLeft(dataElement)) {</span>
<span class="nc" id="L668">                child = parent;</span>
<span class="nc" id="L669">                parent = parent.getParent(dataElement);</span>
            }
<span class="nc" id="L671">            rval = parent;</span>
        }
<span class="nc" id="L673">        return rval;</span>
    }

    //-----------------------------------------------------------------------

    /**
     * Compare two objects
     *
     * @param o1  the first object
     * @param o2  the second object
     *
     * @return negative value if o1 &amp;lt; o2; 0 if o1 == o2; positive
     *         value if o1 &amp;gt; o2
     */
    private static &lt;T extends Comparable&lt;T&gt;&gt; int compare(final T o1, final T o2) {
<span class="nc" id="L688">        return o1.compareTo(o2);</span>
    }

    /**
     * Find the least node from a given node.
     *
     * @param node  the node from which we will start searching
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     * @return the smallest node, from the specified node, in the
     *         specified mapping
     */
    private Node&lt;K, V&gt; leastNode(final Node&lt;K, V&gt; node, final DataElement dataElement) {
<span class="nc" id="L701">        Node&lt;K, V&gt; rval = node;</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">        if (rval != null) {</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">            while (rval.getLeft(dataElement) != null) {</span>
<span class="nc" id="L704">                rval = rval.getLeft(dataElement);</span>
            }
        }
<span class="nc" id="L707">        return rval;</span>
    }

    /**
     * Find the greatest node from a given node.
     *
     * @param node  the node from which we will start searching
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     * @return the greatest node, from the specified node
     */
    private Node&lt;K, V&gt; greatestNode(final Node&lt;K, V&gt; node, final DataElement dataElement) {
<span class="nc" id="L719">        Node&lt;K, V&gt; rval = node;</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">        if (rval != null) {</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">            while (rval.getRight(dataElement) != null) {</span>
<span class="nc" id="L722">                rval = rval.getRight(dataElement);</span>
            }
        }
<span class="nc" id="L725">        return rval;</span>
    }

    /**
     * copy the color from one node to another, dealing with the fact
     * that one or both nodes may, in fact, be null
     *
     * @param from the node whose color we're copying; may be null
     * @param to the node whose color we're changing; may be null
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     */
    private void copyColor(final Node&lt;K, V&gt; from, final Node&lt;K, V&gt; to, final DataElement dataElement) {
<span class="nc bnc" id="L738" title="All 2 branches missed.">        if (to != null) {</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">            if (from == null) {</span>
                // by default, make it black
<span class="nc" id="L741">                to.setBlack(dataElement);</span>
            } else {
<span class="nc" id="L743">                to.copyColor(from, dataElement);</span>
            }
        }
<span class="nc" id="L746">    }</span>

    /**
     * is the specified node red? if the node does not exist, no, it's
     * black, thank you
     *
     * @param node the node (may be null) in question
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     */
    private static boolean isRed(final Node&lt;?, ?&gt; node, final DataElement dataElement) {
<span class="nc bnc" id="L757" title="All 4 branches missed.">        return node != null &amp;&amp; node.isRed(dataElement);</span>
    }

    /**
     * is the specified black red? if the node does not exist, sure,
     * it's black, thank you
     *
     * @param node the node (may be null) in question
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     */
    private static boolean isBlack(final Node&lt;?, ?&gt; node, final DataElement dataElement) {
<span class="nc bnc" id="L769" title="All 4 branches missed.">        return node == null || node.isBlack(dataElement);</span>
    }

    /**
     * force a node (if it exists) red
     *
     * @param node the node (may be null) in question
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     */
    private static void makeRed(final Node&lt;?, ?&gt; node, final DataElement dataElement) {
<span class="nc bnc" id="L780" title="All 2 branches missed.">        if (node != null) {</span>
<span class="nc" id="L781">            node.setRed(dataElement);</span>
        }
<span class="nc" id="L783">    }</span>

    /**
     * force a node (if it exists) black
     *
     * @param node the node (may be null) in question
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     */
    private static void makeBlack(final Node&lt;?, ?&gt; node, final DataElement dataElement) {
<span class="nc bnc" id="L793" title="All 2 branches missed.">        if (node != null) {</span>
<span class="nc" id="L794">            node.setBlack(dataElement);</span>
        }
<span class="nc" id="L796">    }</span>

    /**
     * get a node's grandparent. mind you, the node, its parent, or
     * its grandparent may not exist. no problem
     *
     * @param node the node (may be null) in question
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     */
    private Node&lt;K, V&gt; getGrandParent(final Node&lt;K, V&gt; node, final DataElement dataElement) {
<span class="nc" id="L807">        return getParent(getParent(node, dataElement), dataElement);</span>
    }

    /**
     * get a node's parent. mind you, the node, or its parent, may not
     * exist. no problem
     *
     * @param node the node (may be null) in question
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     */
    private Node&lt;K, V&gt; getParent(final Node&lt;K, V&gt; node, final DataElement dataElement) {
<span class="nc bnc" id="L819" title="All 2 branches missed.">        return node == null ? null : node.getParent(dataElement);</span>
    }

    /**
     * get a node's right child. mind you, the node may not exist. no
     * problem
     *
     * @param node the node (may be null) in question
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     */
    private Node&lt;K, V&gt; getRightChild(final Node&lt;K, V&gt; node, final DataElement dataElement) {
<span class="nc bnc" id="L831" title="All 2 branches missed.">        return node == null ? null : node.getRight(dataElement);</span>
    }

    /**
     * get a node's left child. mind you, the node may not exist. no
     * problem
     *
     * @param node the node (may be null) in question
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     */
    private Node&lt;K, V&gt; getLeftChild(final Node&lt;K, V&gt; node, final DataElement dataElement) {
<span class="nc bnc" id="L843" title="All 2 branches missed.">        return node == null ? null : node.getLeft(dataElement);</span>
    }

    /**
     * do a rotate left. standard fare in the world of balanced trees
     *
     * @param node the node to be rotated
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     */
    private void rotateLeft(final Node&lt;K, V&gt; node, final DataElement dataElement) {
<span class="nc" id="L854">        final Node&lt;K, V&gt; rightChild = node.getRight(dataElement);</span>
<span class="nc" id="L855">        node.setRight(rightChild.getLeft(dataElement), dataElement);</span>

<span class="nc bnc" id="L857" title="All 2 branches missed.">        if (rightChild.getLeft(dataElement) != null) {</span>
<span class="nc" id="L858">            rightChild.getLeft(dataElement).setParent(node, dataElement);</span>
        }
<span class="nc" id="L860">        rightChild.setParent(node.getParent(dataElement), dataElement);</span>

<span class="nc bnc" id="L862" title="All 2 branches missed.">        if (node.getParent(dataElement) == null) {</span>
            // node was the root ... now its right child is the root
<span class="nc" id="L864">            rootNode[dataElement.ordinal()] = rightChild;</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">        } else if (node.getParent(dataElement).getLeft(dataElement) == node) {</span>
<span class="nc" id="L866">            node.getParent(dataElement).setLeft(rightChild, dataElement);</span>
        } else {
<span class="nc" id="L868">            node.getParent(dataElement).setRight(rightChild, dataElement);</span>
        }

<span class="nc" id="L871">        rightChild.setLeft(node, dataElement);</span>
<span class="nc" id="L872">        node.setParent(rightChild, dataElement);</span>
<span class="nc" id="L873">    }</span>

    /**
     * do a rotate right. standard fare in the world of balanced trees
     *
     * @param node the node to be rotated
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     */
    private void rotateRight(final Node&lt;K, V&gt; node, final DataElement dataElement) {
<span class="nc" id="L883">        final Node&lt;K, V&gt; leftChild = node.getLeft(dataElement);</span>
<span class="nc" id="L884">        node.setLeft(leftChild.getRight(dataElement), dataElement);</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">        if (leftChild.getRight(dataElement) != null) {</span>
<span class="nc" id="L886">            leftChild.getRight(dataElement).setParent(node, dataElement);</span>
        }
<span class="nc" id="L888">        leftChild.setParent(node.getParent(dataElement), dataElement);</span>

<span class="nc bnc" id="L890" title="All 2 branches missed.">        if (node.getParent(dataElement) == null) {</span>
            // node was the root ... now its left child is the root
<span class="nc" id="L892">            rootNode[dataElement.ordinal()] = leftChild;</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">        } else if (node.getParent(dataElement).getRight(dataElement) == node) {</span>
<span class="nc" id="L894">            node.getParent(dataElement).setRight(leftChild, dataElement);</span>
        } else {
<span class="nc" id="L896">            node.getParent(dataElement).setLeft(leftChild, dataElement);</span>
        }

<span class="nc" id="L899">        leftChild.setRight(node, dataElement);</span>
<span class="nc" id="L900">        node.setParent(leftChild, dataElement);</span>
<span class="nc" id="L901">    }</span>

    /**
     * complicated red-black insert stuff. Based on Sun's TreeMap
     * implementation, though it's barely recognizable any more
     *
     * @param insertedNode the node to be inserted
     * @param dataElement  the KEY or VALUE int
     */
    private void doRedBlackInsert(final Node&lt;K, V&gt; insertedNode, final DataElement dataElement) {
<span class="nc" id="L911">        Node&lt;K, V&gt; currentNode = insertedNode;</span>
<span class="nc" id="L912">        makeRed(currentNode, dataElement);</span>

<span class="nc bnc" id="L914" title="All 2 branches missed.">        while (currentNode != null</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">            &amp;&amp; currentNode != rootNode[dataElement.ordinal()]</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">            &amp;&amp; isRed(currentNode.getParent(dataElement), dataElement)) {</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">            if (currentNode.isLeftChild(dataElement)) {</span>
<span class="nc" id="L918">                final Node&lt;K, V&gt; y = getRightChild(getGrandParent(currentNode, dataElement), dataElement);</span>

<span class="nc bnc" id="L920" title="All 2 branches missed.">                if (isRed(y, dataElement)) {</span>
<span class="nc" id="L921">                    makeBlack(getParent(currentNode, dataElement), dataElement);</span>
<span class="nc" id="L922">                    makeBlack(y, dataElement);</span>
<span class="nc" id="L923">                    makeRed(getGrandParent(currentNode, dataElement), dataElement);</span>

<span class="nc" id="L925">                    currentNode = getGrandParent(currentNode, dataElement);</span>
                } else {
                    //dead code?
<span class="nc bnc" id="L928" title="All 2 branches missed.">                    if (currentNode.isRightChild(dataElement)) {</span>
<span class="nc" id="L929">                        currentNode = getParent(currentNode, dataElement);</span>

<span class="nc" id="L931">                        rotateLeft(currentNode, dataElement);</span>
                    }

<span class="nc" id="L934">                    makeBlack(getParent(currentNode, dataElement), dataElement);</span>
<span class="nc" id="L935">                    makeRed(getGrandParent(currentNode, dataElement), dataElement);</span>

<span class="nc bnc" id="L937" title="All 2 branches missed.">                    if (getGrandParent(currentNode, dataElement) != null) {</span>
<span class="nc" id="L938">                        rotateRight(getGrandParent(currentNode, dataElement), dataElement);</span>
                    }
                }
<span class="nc" id="L941">            } else {</span>

                // just like clause above, except swap left for right
<span class="nc" id="L944">                final Node&lt;K, V&gt; y = getLeftChild(getGrandParent(currentNode, dataElement), dataElement);</span>

<span class="nc bnc" id="L946" title="All 2 branches missed.">                if (isRed(y, dataElement)) {</span>
<span class="nc" id="L947">                    makeBlack(getParent(currentNode, dataElement), dataElement);</span>
<span class="nc" id="L948">                    makeBlack(y, dataElement);</span>
<span class="nc" id="L949">                    makeRed(getGrandParent(currentNode, dataElement), dataElement);</span>

<span class="nc" id="L951">                    currentNode = getGrandParent(currentNode, dataElement);</span>
                } else {
                    //dead code?
<span class="nc bnc" id="L954" title="All 2 branches missed.">                    if (currentNode.isLeftChild(dataElement)) {</span>
<span class="nc" id="L955">                        currentNode = getParent(currentNode, dataElement);</span>

<span class="nc" id="L957">                        rotateRight(currentNode, dataElement);</span>
                    }

<span class="nc" id="L960">                    makeBlack(getParent(currentNode, dataElement), dataElement);</span>
<span class="nc" id="L961">                    makeRed(getGrandParent(currentNode, dataElement), dataElement);</span>

<span class="nc bnc" id="L963" title="All 2 branches missed.">                    if (getGrandParent(currentNode, dataElement) != null) {</span>
<span class="nc" id="L964">                        rotateLeft(getGrandParent(currentNode, dataElement), dataElement);</span>
                    }
                }
<span class="nc" id="L967">            }</span>
        }

<span class="nc" id="L970">        makeBlack(rootNode[dataElement.ordinal()], dataElement);</span>
<span class="nc" id="L971">    }</span>

    /**
     * complicated red-black delete stuff. Based on Sun's TreeMap
     * implementation, though it's barely recognizable any more
     *
     * @param deletedNode the node to be deleted
     */
    private void doRedBlackDelete(final Node&lt;K, V&gt; deletedNode) {
<span class="nc bnc" id="L980" title="All 2 branches missed.">        for (final DataElement dataElement : DataElement.values()) {</span>
            // if deleted node has both left and children, swap with
            // the next greater node
<span class="nc bnc" id="L983" title="All 4 branches missed.">            if (deletedNode.getLeft(dataElement) != null &amp;&amp; deletedNode.getRight(dataElement) != null) {</span>
<span class="nc" id="L984">                swapPosition(nextGreater(deletedNode, dataElement), deletedNode, dataElement);</span>
            }

<span class="nc bnc" id="L987" title="All 2 branches missed.">            final Node&lt;K, V&gt; replacement = deletedNode.getLeft(dataElement) != null ?</span>
<span class="nc" id="L988">                    deletedNode.getLeft(dataElement) : deletedNode.getRight(dataElement);</span>

<span class="nc bnc" id="L990" title="All 2 branches missed.">            if (replacement != null) {</span>
<span class="nc" id="L991">                replacement.setParent(deletedNode.getParent(dataElement), dataElement);</span>

<span class="nc bnc" id="L993" title="All 2 branches missed.">                if (deletedNode.getParent(dataElement) == null) {</span>
<span class="nc" id="L994">                    rootNode[dataElement.ordinal()] = replacement;</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">                } else if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {</span>
<span class="nc" id="L996">                    deletedNode.getParent(dataElement).setLeft(replacement, dataElement);</span>
                } else {
<span class="nc" id="L998">                    deletedNode.getParent(dataElement).setRight(replacement, dataElement);</span>
                }

<span class="nc" id="L1001">                deletedNode.setLeft(null, dataElement);</span>
<span class="nc" id="L1002">                deletedNode.setRight(null, dataElement);</span>
<span class="nc" id="L1003">                deletedNode.setParent(null, dataElement);</span>

<span class="nc bnc" id="L1005" title="All 2 branches missed.">                if (isBlack(deletedNode, dataElement)) {</span>
<span class="nc" id="L1006">                    doRedBlackDeleteFixup(replacement, dataElement);</span>
                }
            } else {

                // replacement is null
<span class="nc bnc" id="L1011" title="All 2 branches missed.">                if (deletedNode.getParent(dataElement) == null) {</span>

                    // empty tree
<span class="nc" id="L1014">                    rootNode[dataElement.ordinal()] = null;</span>
                } else {

                    // deleted node had no children
<span class="nc bnc" id="L1018" title="All 2 branches missed.">                    if (isBlack(deletedNode, dataElement)) {</span>
<span class="nc" id="L1019">                        doRedBlackDeleteFixup(deletedNode, dataElement);</span>
                    }

<span class="nc bnc" id="L1022" title="All 2 branches missed.">                    if (deletedNode.getParent(dataElement) != null) {</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">                        if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {</span>
<span class="nc" id="L1024">                            deletedNode.getParent(dataElement).setLeft(null, dataElement);</span>
                        } else {
<span class="nc" id="L1026">                            deletedNode.getParent(dataElement).setRight(null, dataElement);</span>
                        }

<span class="nc" id="L1029">                        deletedNode.setParent(null, dataElement);</span>
                    }
                }
            }
        }
<span class="nc" id="L1034">        shrink();</span>
<span class="nc" id="L1035">    }</span>

    /**
     * complicated red-black delete stuff. Based on Sun's TreeMap
     * implementation, though it's barely recognizable any more. This
     * rebalances the tree (somewhat, as red-black trees are not
     * perfectly balanced -- perfect balancing takes longer)
     *
     * @param replacementNode the node being replaced
     * @param dataElement  the KEY or VALUE int
     */
    private void doRedBlackDeleteFixup(final Node&lt;K, V&gt; replacementNode, final DataElement dataElement) {
<span class="nc" id="L1047">        Node&lt;K, V&gt; currentNode = replacementNode;</span>

<span class="nc bnc" id="L1049" title="All 4 branches missed.">        while (currentNode != rootNode[dataElement.ordinal()] &amp;&amp; isBlack(currentNode, dataElement)) {</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">            if (currentNode.isLeftChild(dataElement)) {</span>
<span class="nc" id="L1051">                Node&lt;K, V&gt; siblingNode = getRightChild(getParent(currentNode, dataElement), dataElement);</span>

<span class="nc bnc" id="L1053" title="All 2 branches missed.">                if (isRed(siblingNode, dataElement)) {</span>
<span class="nc" id="L1054">                    makeBlack(siblingNode, dataElement);</span>
<span class="nc" id="L1055">                    makeRed(getParent(currentNode, dataElement), dataElement);</span>
<span class="nc" id="L1056">                    rotateLeft(getParent(currentNode, dataElement), dataElement);</span>

<span class="nc" id="L1058">                    siblingNode = getRightChild(getParent(currentNode, dataElement), dataElement);</span>
                }

<span class="nc bnc" id="L1061" title="All 2 branches missed.">                if (isBlack(getLeftChild(siblingNode, dataElement), dataElement)</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">                    &amp;&amp; isBlack(getRightChild(siblingNode, dataElement), dataElement)) {</span>
<span class="nc" id="L1063">                    makeRed(siblingNode, dataElement);</span>

<span class="nc" id="L1065">                    currentNode = getParent(currentNode, dataElement);</span>
                } else {
<span class="nc bnc" id="L1067" title="All 2 branches missed.">                    if (isBlack(getRightChild(siblingNode, dataElement), dataElement)) {</span>
<span class="nc" id="L1068">                        makeBlack(getLeftChild(siblingNode, dataElement), dataElement);</span>
<span class="nc" id="L1069">                        makeRed(siblingNode, dataElement);</span>
<span class="nc" id="L1070">                        rotateRight(siblingNode, dataElement);</span>

<span class="nc" id="L1072">                        siblingNode = getRightChild(getParent(currentNode, dataElement), dataElement);</span>
                    }

<span class="nc" id="L1075">                    copyColor(getParent(currentNode, dataElement), siblingNode, dataElement);</span>
<span class="nc" id="L1076">                    makeBlack(getParent(currentNode, dataElement), dataElement);</span>
<span class="nc" id="L1077">                    makeBlack(getRightChild(siblingNode, dataElement), dataElement);</span>
<span class="nc" id="L1078">                    rotateLeft(getParent(currentNode, dataElement), dataElement);</span>

<span class="nc" id="L1080">                    currentNode = rootNode[dataElement.ordinal()];</span>
                }
<span class="nc" id="L1082">            } else {</span>
<span class="nc" id="L1083">                Node&lt;K, V&gt; siblingNode = getLeftChild(getParent(currentNode, dataElement), dataElement);</span>

<span class="nc bnc" id="L1085" title="All 2 branches missed.">                if (isRed(siblingNode, dataElement)) {</span>
<span class="nc" id="L1086">                    makeBlack(siblingNode, dataElement);</span>
<span class="nc" id="L1087">                    makeRed(getParent(currentNode, dataElement), dataElement);</span>
<span class="nc" id="L1088">                    rotateRight(getParent(currentNode, dataElement), dataElement);</span>

<span class="nc" id="L1090">                    siblingNode = getLeftChild(getParent(currentNode, dataElement), dataElement);</span>
                }

<span class="nc bnc" id="L1093" title="All 2 branches missed.">                if (isBlack(getRightChild(siblingNode, dataElement), dataElement)</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">                    &amp;&amp; isBlack(getLeftChild(siblingNode, dataElement), dataElement)) {</span>
<span class="nc" id="L1095">                    makeRed(siblingNode, dataElement);</span>

<span class="nc" id="L1097">                    currentNode = getParent(currentNode, dataElement);</span>
                } else {
<span class="nc bnc" id="L1099" title="All 2 branches missed.">                    if (isBlack(getLeftChild(siblingNode, dataElement), dataElement)) {</span>
<span class="nc" id="L1100">                        makeBlack(getRightChild(siblingNode, dataElement), dataElement);</span>
<span class="nc" id="L1101">                        makeRed(siblingNode, dataElement);</span>
<span class="nc" id="L1102">                        rotateLeft(siblingNode, dataElement);</span>

<span class="nc" id="L1104">                        siblingNode = getLeftChild(getParent(currentNode, dataElement), dataElement);</span>
                    }

<span class="nc" id="L1107">                    copyColor(getParent(currentNode, dataElement), siblingNode, dataElement);</span>
<span class="nc" id="L1108">                    makeBlack(getParent(currentNode, dataElement), dataElement);</span>
<span class="nc" id="L1109">                    makeBlack(getLeftChild(siblingNode, dataElement), dataElement);</span>
<span class="nc" id="L1110">                    rotateRight(getParent(currentNode, dataElement), dataElement);</span>

<span class="nc" id="L1112">                    currentNode = rootNode[dataElement.ordinal()];</span>
                }
<span class="nc" id="L1114">            }</span>
        }

<span class="nc" id="L1117">        makeBlack(currentNode, dataElement);</span>
<span class="nc" id="L1118">    }</span>

    /**
     * swap two nodes (except for their content), taking care of
     * special cases where one is the other's parent ... hey, it
     * happens.
     *
     * @param x one node
     * @param y another node
     * @param dataElement  the KEY or VALUE int
     */
    private void swapPosition(final Node&lt;K, V&gt; x, final Node&lt;K, V&gt; y, final DataElement dataElement) {
        // Save initial values.
<span class="nc" id="L1131">        final Node&lt;K, V&gt; xFormerParent = x.getParent(dataElement);</span>
<span class="nc" id="L1132">        final Node&lt;K, V&gt; xFormerLeftChild = x.getLeft(dataElement);</span>
<span class="nc" id="L1133">        final Node&lt;K, V&gt; xFormerRightChild = x.getRight(dataElement);</span>
<span class="nc" id="L1134">        final Node&lt;K, V&gt; yFormerParent = y.getParent(dataElement);</span>
<span class="nc" id="L1135">        final Node&lt;K, V&gt; yFormerLeftChild = y.getLeft(dataElement);</span>
<span class="nc" id="L1136">        final Node&lt;K, V&gt; yFormerRightChild = y.getRight(dataElement);</span>
<span class="nc" id="L1137">        final boolean xWasLeftChild =</span>
<span class="nc bnc" id="L1138" title="All 4 branches missed.">                x.getParent(dataElement) != null &amp;&amp; x == x.getParent(dataElement).getLeft(dataElement);</span>
<span class="nc" id="L1139">        final boolean yWasLeftChild =</span>
<span class="nc bnc" id="L1140" title="All 4 branches missed.">                y.getParent(dataElement) != null &amp;&amp; y == y.getParent(dataElement).getLeft(dataElement);</span>

        // Swap, handling special cases of one being the other's parent.
<span class="nc bnc" id="L1143" title="All 2 branches missed.">        if (x == yFormerParent) { // x was y's parent</span>
<span class="nc" id="L1144">            x.setParent(y, dataElement);</span>

<span class="nc bnc" id="L1146" title="All 2 branches missed.">            if (yWasLeftChild) {</span>
<span class="nc" id="L1147">                y.setLeft(x, dataElement);</span>
<span class="nc" id="L1148">                y.setRight(xFormerRightChild, dataElement);</span>
            } else {
<span class="nc" id="L1150">                y.setRight(x, dataElement);</span>
<span class="nc" id="L1151">                y.setLeft(xFormerLeftChild, dataElement);</span>
            }
        } else {
<span class="nc" id="L1154">            x.setParent(yFormerParent, dataElement);</span>

<span class="nc bnc" id="L1156" title="All 2 branches missed.">            if (yFormerParent != null) {</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">                if (yWasLeftChild) {</span>
<span class="nc" id="L1158">                    yFormerParent.setLeft(x, dataElement);</span>
                } else {
<span class="nc" id="L1160">                    yFormerParent.setRight(x, dataElement);</span>
                }
            }

<span class="nc" id="L1164">            y.setLeft(xFormerLeftChild, dataElement);</span>
<span class="nc" id="L1165">            y.setRight(xFormerRightChild, dataElement);</span>
        }

<span class="nc bnc" id="L1168" title="All 2 branches missed.">        if (y == xFormerParent) { // y was x's parent</span>
<span class="nc" id="L1169">            y.setParent(x, dataElement);</span>

<span class="nc bnc" id="L1171" title="All 2 branches missed.">            if (xWasLeftChild) {</span>
<span class="nc" id="L1172">                x.setLeft(y, dataElement);</span>
<span class="nc" id="L1173">                x.setRight(yFormerRightChild, dataElement);</span>
            } else {
<span class="nc" id="L1175">                x.setRight(y, dataElement);</span>
<span class="nc" id="L1176">                x.setLeft(yFormerLeftChild, dataElement);</span>
            }
        } else {
<span class="nc" id="L1179">            y.setParent(xFormerParent, dataElement);</span>

<span class="nc bnc" id="L1181" title="All 2 branches missed.">            if (xFormerParent != null) {</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">                if (xWasLeftChild) {</span>
<span class="nc" id="L1183">                    xFormerParent.setLeft(y, dataElement);</span>
                } else {
<span class="nc" id="L1185">                    xFormerParent.setRight(y, dataElement);</span>
                }
            }

<span class="nc" id="L1189">            x.setLeft(yFormerLeftChild, dataElement);</span>
<span class="nc" id="L1190">            x.setRight(yFormerRightChild, dataElement);</span>
        }

        // Fix children's parent pointers
<span class="nc bnc" id="L1194" title="All 2 branches missed.">        if (x.getLeft(dataElement) != null) {</span>
<span class="nc" id="L1195">            x.getLeft(dataElement).setParent(x, dataElement);</span>
        }

<span class="nc bnc" id="L1198" title="All 2 branches missed.">        if (x.getRight(dataElement) != null) {</span>
<span class="nc" id="L1199">            x.getRight(dataElement).setParent(x, dataElement);</span>
        }

<span class="nc bnc" id="L1202" title="All 2 branches missed.">        if (y.getLeft(dataElement) != null) {</span>
<span class="nc" id="L1203">            y.getLeft(dataElement).setParent(y, dataElement);</span>
        }

<span class="nc bnc" id="L1206" title="All 2 branches missed.">        if (y.getRight(dataElement) != null) {</span>
<span class="nc" id="L1207">            y.getRight(dataElement).setParent(y, dataElement);</span>
        }

<span class="nc" id="L1210">        x.swapColors(y, dataElement);</span>

        // Check if root changed
<span class="nc bnc" id="L1213" title="All 2 branches missed.">        if (rootNode[dataElement.ordinal()] == x) {</span>
<span class="nc" id="L1214">            rootNode[dataElement.ordinal()] = y;</span>
<span class="nc bnc" id="L1215" title="All 2 branches missed.">        } else if (rootNode[dataElement.ordinal()] == y) {</span>
<span class="nc" id="L1216">            rootNode[dataElement.ordinal()] = x;</span>
        }
<span class="nc" id="L1218">    }</span>

    /**
     * check if an object is fit to be proper input ... has to be
     * Comparable and non-null
     *
     * @param o the object being checked
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     *
     * @throws NullPointerException if o is null
     * @throws ClassCastException if o is not Comparable
     */
    private static void checkNonNullComparable(final Object o, final DataElement dataElement) {
<span class="nc bnc" id="L1232" title="All 2 branches missed.">        if (o == null) {</span>
<span class="nc" id="L1233">            throw new NullPointerException(dataElement + &quot; cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L1235" title="All 2 branches missed.">        if (!(o instanceof Comparable)) {</span>
<span class="nc" id="L1236">            throw new ClassCastException(dataElement + &quot; must be Comparable&quot;);</span>
        }
<span class="nc" id="L1238">    }</span>

    /**
     * check a key for validity (non-null and implements Comparable)
     *
     * @param key the key to be checked
     *
     * @throws NullPointerException if key is null
     * @throws ClassCastException if key is not Comparable
     */
    private static void checkKey(final Object key) {
<span class="nc" id="L1249">        checkNonNullComparable(key, DataElement.KEY);</span>
<span class="nc" id="L1250">    }</span>

    /**
     * check a value for validity (non-null and implements Comparable)
     *
     * @param value the value to be checked
     *
     * @throws NullPointerException if value is null
     * @throws ClassCastException if value is not Comparable
     */
    private static void checkValue(final Object value) {
<span class="nc" id="L1261">        checkNonNullComparable(value, DataElement.VALUE);</span>
<span class="nc" id="L1262">    }</span>

    /**
     * check a key and a value for validity (non-null and implements
     * Comparable)
     *
     * @param key the key to be checked
     * @param value the value to be checked
     *
     * @throws NullPointerException if key or value is null
     * @throws ClassCastException if key or value is not Comparable
     */
    private static void checkKeyAndValue(final Object key, final Object value) {
<span class="nc" id="L1275">        checkKey(key);</span>
<span class="nc" id="L1276">        checkValue(value);</span>
<span class="nc" id="L1277">    }</span>

    /**
     * increment the modification count -- used to check for
     * concurrent modification of the map through the map and through
     * an Iterator from one of its Set or Collection views
     */
    private void modify() {
<span class="nc" id="L1285">        modifications++;</span>
<span class="nc" id="L1286">    }</span>

    /**
     * bump up the size and note that the map has changed
     */
    private void grow() {
<span class="nc" id="L1292">        modify();</span>
<span class="nc" id="L1293">        nodeCount++;</span>
<span class="nc" id="L1294">    }</span>

    /**
     * decrement the size and note that the map has changed
     */
    private void shrink() {
<span class="nc" id="L1300">        modify();</span>
<span class="nc" id="L1301">        nodeCount--;</span>
<span class="nc" id="L1302">    }</span>

    /**
     * insert a node by its value
     *
     * @param newNode the node to be inserted
     *
     * @throws IllegalArgumentException if the node already exists
     *                                     in the value mapping
     */
    private void insertValue(final Node&lt;K, V&gt; newNode) throws IllegalArgumentException {
<span class="nc" id="L1313">        Node&lt;K, V&gt; node = rootNode[DataElement.VALUE.ordinal()];</span>

        while (true) {
<span class="nc" id="L1316">            final int cmp = compare(newNode.getValue(), node.getValue());</span>

<span class="nc bnc" id="L1318" title="All 2 branches missed.">            if (cmp == 0) {</span>
<span class="nc" id="L1319">                throw new IllegalArgumentException(</span>
<span class="nc" id="L1320">                    &quot;Cannot store a duplicate value (\&quot;&quot; + newNode.getData(DataElement.VALUE) + &quot;\&quot;) in this Map&quot;);</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">            } else if (cmp &lt; 0) {</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">                if (node.getLeft(DataElement.VALUE) != null) {</span>
<span class="nc" id="L1323">                    node = node.getLeft(DataElement.VALUE);</span>
                } else {
<span class="nc" id="L1325">                    node.setLeft(newNode, DataElement.VALUE);</span>
<span class="nc" id="L1326">                    newNode.setParent(node, DataElement.VALUE);</span>
<span class="nc" id="L1327">                    doRedBlackInsert(newNode, DataElement.VALUE);</span>

<span class="nc" id="L1329">                    break;</span>
                }
            } else { // cmp &gt; 0
<span class="nc bnc" id="L1332" title="All 2 branches missed.">                if (node.getRight(DataElement.VALUE) != null) {</span>
<span class="nc" id="L1333">                    node = node.getRight(DataElement.VALUE);</span>
                } else {
<span class="nc" id="L1335">                    node.setRight(newNode, DataElement.VALUE);</span>
<span class="nc" id="L1336">                    newNode.setParent(node, DataElement.VALUE);</span>
<span class="nc" id="L1337">                    doRedBlackInsert(newNode, DataElement.VALUE);</span>

<span class="nc" id="L1339">                    break;</span>
                }
            }
<span class="nc" id="L1342">        }</span>
<span class="nc" id="L1343">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Compares for equals as per the API.
     *
     * @param obj  the object to compare to
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     * @return true if equal
     */
    private boolean doEquals(final Object obj, final DataElement dataElement) {
<span class="nc bnc" id="L1355" title="All 2 branches missed.">        if (obj == this) {</span>
<span class="nc" id="L1356">            return true;</span>
        }
<span class="nc bnc" id="L1358" title="All 2 branches missed.">        if (!(obj instanceof Map)) {</span>
<span class="nc" id="L1359">            return false;</span>
        }
<span class="nc" id="L1361">        final Map&lt;?, ?&gt; other = (Map&lt;?, ?&gt;) obj;</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">        if (other.size() != size()) {</span>
<span class="nc" id="L1363">            return false;</span>
        }

<span class="nc bnc" id="L1366" title="All 2 branches missed.">        if (nodeCount &gt; 0) {</span>
            try {
<span class="nc bnc" id="L1368" title="All 2 branches missed.">                for (final MapIterator&lt;?, ?&gt; it = getMapIterator(dataElement); it.hasNext(); ) {</span>
<span class="nc" id="L1369">                    final Object key = it.next();</span>
<span class="nc" id="L1370">                    final Object value = it.getValue();</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">                    if (!value.equals(other.get(key))) {</span>
<span class="nc" id="L1372">                        return false;</span>
                    }
<span class="nc" id="L1374">                }</span>
<span class="nc" id="L1375">            } catch (final ClassCastException | NullPointerException ex) {</span>
<span class="nc" id="L1376">                return false;</span>
<span class="nc" id="L1377">            }</span>
        }
<span class="nc" id="L1379">        return true;</span>
    }

    /**
     * Gets the hash code value for this map as per the API.
     *
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     * @return the hash code value for this map
     */
    private int doHashCode(final DataElement dataElement) {
<span class="nc" id="L1390">        int total = 0;</span>
<span class="nc bnc" id="L1391" title="All 2 branches missed.">        if (nodeCount &gt; 0) {</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">            for (final MapIterator&lt;?, ?&gt; it = getMapIterator(dataElement); it.hasNext(); ) {</span>
<span class="nc" id="L1393">                final Object key = it.next();</span>
<span class="nc" id="L1394">                final Object value = it.getValue();</span>
<span class="nc" id="L1395">                total += key.hashCode() ^ value.hashCode();</span>
<span class="nc" id="L1396">            }</span>
        }
<span class="nc" id="L1398">        return total;</span>
    }

    /**
     * Gets the string form of this map as per AbstractMap.
     *
     * @param dataElement  either {@link DataElement#KEY} key}
     *                     or the {@link DataElement#VALUE value}.
     * @return the string form of this map
     */
    private String doToString(final DataElement dataElement) {
<span class="nc bnc" id="L1409" title="All 2 branches missed.">        if (nodeCount == 0) {</span>
<span class="nc" id="L1410">            return &quot;{}&quot;;</span>
        }
<span class="nc" id="L1412">        final StringBuilder buf = new StringBuilder(nodeCount * 32);</span>
<span class="nc" id="L1413">        buf.append('{');</span>
<span class="nc" id="L1414">        final MapIterator&lt;?, ?&gt; it = getMapIterator(dataElement);</span>
<span class="nc" id="L1415">        boolean hasNext = it.hasNext();</span>
<span class="nc bnc" id="L1416" title="All 2 branches missed.">        while (hasNext) {</span>
<span class="nc" id="L1417">            final Object key = it.next();</span>
<span class="nc" id="L1418">            final Object value = it.getValue();</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">            buf.append(key == this ? &quot;(this Map)&quot; : key)</span>
<span class="nc bnc" id="L1420" title="All 2 branches missed.">               .append('=')</span>
<span class="nc" id="L1421">               .append(value == this ? &quot;(this Map)&quot; : value);</span>

<span class="nc" id="L1423">            hasNext = it.hasNext();</span>
<span class="nc bnc" id="L1424" title="All 2 branches missed.">            if (hasNext) {</span>
<span class="nc" id="L1425">                buf.append(&quot;, &quot;);</span>
            }
<span class="nc" id="L1427">        }</span>

<span class="nc" id="L1429">        buf.append('}');</span>
<span class="nc" id="L1430">        return buf.toString();</span>
    }

    private MapIterator&lt;?, ?&gt; getMapIterator(final DataElement dataElement) {
<span class="nc bnc" id="L1434" title="All 3 branches missed.">        switch (dataElement) {</span>
        case KEY:
<span class="nc" id="L1436">            return new ViewMapIterator(DataElement.KEY);</span>
        case VALUE:
<span class="nc" id="L1438">            return new InverseViewMapIterator(DataElement.VALUE);</span>
        default:
<span class="nc" id="L1440">            throw new IllegalArgumentException();</span>
        }
    }

    /**
     * Reads the content of the stream.
     *
     * @param stream the input stream
     * @throws IOException if an error occurs while reading from the stream
     * @throws ClassNotFoundException if an object read from the stream can not be loaded
     */
    @SuppressWarnings(&quot;unchecked&quot;) // This will fail at runtime if the stream is incorrect
    private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException{
<span class="nc" id="L1453">        stream.defaultReadObject();</span>
<span class="nc" id="L1454">        rootNode = new Node[2];</span>
<span class="nc" id="L1455">        final int size = stream.readInt();</span>
<span class="nc bnc" id="L1456" title="All 2 branches missed.">        for(int i = 0; i &lt; size; i++){</span>
<span class="nc" id="L1457">            final K k =(K) stream.readObject();</span>
<span class="nc" id="L1458">            final V v =(V) stream.readObject();</span>
<span class="nc" id="L1459">            put(k, v);</span>
        }
<span class="nc" id="L1461">    }</span>

    /**
     * Writes the content to the stream for serialization.
     *
     * @param stream  the output stream
     * @throws IOException if an error occurs while writing to the stream
     */
    private void writeObject(final ObjectOutputStream stream) throws IOException{
<span class="nc" id="L1470">        stream.defaultWriteObject();</span>
<span class="nc" id="L1471">        stream.writeInt(this.size());</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">        for (final Entry&lt;K, V&gt; entry : entrySet()) {</span>
<span class="nc" id="L1473">            stream.writeObject(entry.getKey());</span>
<span class="nc" id="L1474">            stream.writeObject(entry.getValue());</span>
<span class="nc" id="L1475">        }</span>
<span class="nc" id="L1476">    }</span>

    //-----------------------------------------------------------------------
    /**
     * A view of this map.
     */
    abstract class View&lt;E&gt; extends AbstractSet&lt;E&gt; {

        /** Whether to return KEY or VALUE order. */
        final DataElement orderType;

        /**
         * Constructor.
         * @param orderType  the KEY or VALUE int for the order
         */
<span class="nc" id="L1491">        View(final DataElement orderType) {</span>
<span class="nc" id="L1492">            super();</span>
<span class="nc" id="L1493">            this.orderType = orderType;</span>
<span class="nc" id="L1494">        }</span>

        @Override
        public int size() {
<span class="nc" id="L1498">            return TreeBidiMap.this.size();</span>
        }

        @Override
        public void clear() {
<span class="nc" id="L1503">            TreeBidiMap.this.clear();</span>
<span class="nc" id="L1504">        }</span>
    }

    class KeyView extends View&lt;K&gt; {

        /**
         * Create a new TreeBidiMap.KeyView.
         */
<span class="nc" id="L1512">        public KeyView(final DataElement orderType) {</span>
<span class="nc" id="L1513">            super(orderType);</span>
<span class="nc" id="L1514">        }</span>

        @Override
        public Iterator&lt;K&gt; iterator() {
<span class="nc" id="L1518">            return new ViewMapIterator(orderType);</span>
        }

        @Override
        public boolean contains(final Object obj) {
<span class="nc" id="L1523">            checkNonNullComparable(obj, DataElement.KEY);</span>
<span class="nc bnc" id="L1524" title="All 2 branches missed.">            return lookupKey(obj) != null;</span>
        }

        @Override
        public boolean remove(final Object o) {
<span class="nc bnc" id="L1529" title="All 2 branches missed.">            return doRemoveKey(o) != null;</span>
        }

    }

    class ValueView extends View&lt;V&gt; {

        /**
         * Create a new TreeBidiMap.ValueView.
         */
<span class="nc" id="L1539">        public ValueView(final DataElement orderType) {</span>
<span class="nc" id="L1540">            super(orderType);</span>
<span class="nc" id="L1541">        }</span>

        @Override
        public Iterator&lt;V&gt; iterator() {
<span class="nc" id="L1545">            return new InverseViewMapIterator(orderType);</span>
        }

        @Override
        public boolean contains(final Object obj) {
<span class="nc" id="L1550">            checkNonNullComparable(obj, DataElement.VALUE);</span>
<span class="nc bnc" id="L1551" title="All 2 branches missed.">            return lookupValue(obj) != null;</span>
        }

        @Override
        public boolean remove(final Object o) {
<span class="nc bnc" id="L1556" title="All 2 branches missed.">            return doRemoveValue(o) != null;</span>
        }

    }

    /**
     * A view of this map.
     */
    class EntryView extends View&lt;Entry&lt;K, V&gt;&gt; {

<span class="nc" id="L1566">        EntryView() {</span>
<span class="nc" id="L1567">            super(DataElement.KEY);</span>
<span class="nc" id="L1568">        }</span>

        @Override
        public boolean contains(final Object obj) {
<span class="nc bnc" id="L1572" title="All 2 branches missed.">            if (!(obj instanceof Map.Entry)) {</span>
<span class="nc" id="L1573">                return false;</span>
            }
<span class="nc" id="L1575">            final Entry&lt;?, ?&gt; entry = (Entry&lt;?, ?&gt;) obj;</span>
<span class="nc" id="L1576">            final Object value = entry.getValue();</span>
<span class="nc" id="L1577">            final Node&lt;K, V&gt; node = lookupKey(entry.getKey());</span>
<span class="nc bnc" id="L1578" title="All 4 branches missed.">            return node != null &amp;&amp; node.getValue().equals(value);</span>
        }

        @Override
        public boolean remove(final Object obj) {
<span class="nc bnc" id="L1583" title="All 2 branches missed.">            if (!(obj instanceof Map.Entry)) {</span>
<span class="nc" id="L1584">                return false;</span>
            }
<span class="nc" id="L1586">            final Entry&lt;?, ?&gt; entry = (Entry&lt;?, ?&gt;) obj;</span>
<span class="nc" id="L1587">            final Object value = entry.getValue();</span>
<span class="nc" id="L1588">            final Node&lt;K, V&gt; node = lookupKey(entry.getKey());</span>
<span class="nc bnc" id="L1589" title="All 4 branches missed.">            if (node != null &amp;&amp; node.getValue().equals(value)) {</span>
<span class="nc" id="L1590">                doRedBlackDelete(node);</span>
<span class="nc" id="L1591">                return true;</span>
            }
<span class="nc" id="L1593">            return false;</span>
        }

        @Override
        public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() {
<span class="nc" id="L1598">            return new ViewMapEntryIterator();</span>
        }
    }

    /**
     * A view of this map.
     */
    class InverseEntryView extends View&lt;Entry&lt;V, K&gt;&gt; {

<span class="nc" id="L1607">        InverseEntryView() {</span>
<span class="nc" id="L1608">            super(DataElement.VALUE);</span>
<span class="nc" id="L1609">        }</span>

        @Override
        public boolean contains(final Object obj) {
<span class="nc bnc" id="L1613" title="All 2 branches missed.">            if (!(obj instanceof Map.Entry)) {</span>
<span class="nc" id="L1614">                return false;</span>
            }
<span class="nc" id="L1616">            final Entry&lt;?, ?&gt; entry = (Entry&lt;?, ?&gt;) obj;</span>
<span class="nc" id="L1617">            final Object value = entry.getValue();</span>
<span class="nc" id="L1618">            final Node&lt;K, V&gt; node = lookupValue(entry.getKey());</span>
<span class="nc bnc" id="L1619" title="All 4 branches missed.">            return node != null &amp;&amp; node.getKey().equals(value);</span>
        }

        @Override
        public boolean remove(final Object obj) {
<span class="nc bnc" id="L1624" title="All 2 branches missed.">            if (!(obj instanceof Map.Entry)) {</span>
<span class="nc" id="L1625">                return false;</span>
            }
<span class="nc" id="L1627">            final Entry&lt;?, ?&gt; entry = (Entry&lt;?, ?&gt;) obj;</span>
<span class="nc" id="L1628">            final Object value = entry.getValue();</span>
<span class="nc" id="L1629">            final Node&lt;K, V&gt; node = lookupValue(entry.getKey());</span>
<span class="nc bnc" id="L1630" title="All 4 branches missed.">            if (node != null &amp;&amp; node.getKey().equals(value)) {</span>
<span class="nc" id="L1631">                doRedBlackDelete(node);</span>
<span class="nc" id="L1632">                return true;</span>
            }
<span class="nc" id="L1634">            return false;</span>
        }

        @Override
        public Iterator&lt;Entry&lt;V, K&gt;&gt; iterator() {
<span class="nc" id="L1639">            return new InverseViewMapEntryIterator();</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * An iterator over the map.
     */
    abstract class ViewIterator {

        /** Whether to return KEY or VALUE order. */
        private final DataElement orderType;
        /** The last node returned by the iterator. */
        Node&lt;K, V&gt; lastReturnedNode;
        /** The next node to be returned by the iterator. */
        private Node&lt;K, V&gt; nextNode;
        /** The previous node in the sequence returned by the iterator. */
        private Node&lt;K, V&gt; previousNode;
        /** The modification count. */
        private int expectedModifications;

        /**
         * Constructor.
         * @param orderType  the KEY or VALUE int for the order
         */
<span class="nc" id="L1664">        ViewIterator(final DataElement orderType) {</span>
<span class="nc" id="L1665">            super();</span>
<span class="nc" id="L1666">            this.orderType = orderType;</span>
<span class="nc" id="L1667">            expectedModifications = modifications;</span>
<span class="nc" id="L1668">            nextNode = leastNode(rootNode[orderType.ordinal()], orderType);</span>
<span class="nc" id="L1669">            lastReturnedNode = null;</span>
<span class="nc" id="L1670">            previousNode = null;</span>
<span class="nc" id="L1671">        }</span>

        public final boolean hasNext() {
<span class="nc bnc" id="L1674" title="All 2 branches missed.">            return nextNode != null;</span>
        }

        protected Node&lt;K, V&gt; navigateNext() {
<span class="nc bnc" id="L1678" title="All 2 branches missed.">            if (nextNode == null) {</span>
<span class="nc" id="L1679">                throw new NoSuchElementException();</span>
            }
<span class="nc bnc" id="L1681" title="All 2 branches missed.">            if (modifications != expectedModifications) {</span>
<span class="nc" id="L1682">                throw new ConcurrentModificationException();</span>
            }
<span class="nc" id="L1684">            lastReturnedNode = nextNode;</span>
<span class="nc" id="L1685">            previousNode = nextNode;</span>
<span class="nc" id="L1686">            nextNode = nextGreater(nextNode, orderType);</span>
<span class="nc" id="L1687">            return lastReturnedNode;</span>
        }

        public boolean hasPrevious() {
<span class="nc bnc" id="L1691" title="All 2 branches missed.">            return previousNode != null;</span>
        }

        protected Node&lt;K, V&gt; navigatePrevious() {
<span class="nc bnc" id="L1695" title="All 2 branches missed.">            if (previousNode == null) {</span>
<span class="nc" id="L1696">                throw new NoSuchElementException();</span>
            }
<span class="nc bnc" id="L1698" title="All 2 branches missed.">            if (modifications != expectedModifications) {</span>
<span class="nc" id="L1699">                throw new ConcurrentModificationException();</span>
            }
<span class="nc" id="L1701">            nextNode = lastReturnedNode;</span>
<span class="nc bnc" id="L1702" title="All 2 branches missed.">            if (nextNode == null) {</span>
<span class="nc" id="L1703">                nextNode = nextGreater(previousNode, orderType);</span>
            }
<span class="nc" id="L1705">            lastReturnedNode = previousNode;</span>
<span class="nc" id="L1706">            previousNode = nextSmaller(previousNode, orderType);</span>
<span class="nc" id="L1707">            return lastReturnedNode;</span>
        }

        public final void remove() {
<span class="nc bnc" id="L1711" title="All 2 branches missed.">            if (lastReturnedNode == null) {</span>
<span class="nc" id="L1712">                throw new IllegalStateException();</span>
            }
<span class="nc bnc" id="L1714" title="All 2 branches missed.">            if (modifications != expectedModifications) {</span>
<span class="nc" id="L1715">                throw new ConcurrentModificationException();</span>
            }
<span class="nc" id="L1717">            doRedBlackDelete(lastReturnedNode);</span>
<span class="nc" id="L1718">            expectedModifications++;</span>
<span class="nc" id="L1719">            lastReturnedNode = null;</span>
<span class="nc bnc" id="L1720" title="All 2 branches missed.">            if (nextNode == null) {</span>
<span class="nc" id="L1721">                previousNode = greatestNode(rootNode[orderType.ordinal()], orderType);</span>
            } else {
<span class="nc" id="L1723">                previousNode = nextSmaller(nextNode, orderType);</span>
            }
<span class="nc" id="L1725">        }</span>
    }

    //-----------------------------------------------------------------------
    /**
     * An iterator over the map.
     */
    class ViewMapIterator extends ViewIterator implements OrderedMapIterator&lt;K, V&gt; {

        /**
         * Constructor.
         */
<span class="nc" id="L1737">        ViewMapIterator(final DataElement orderType) {</span>
<span class="nc" id="L1738">            super(orderType);</span>
<span class="nc" id="L1739">        }</span>

        @Override
        public K getKey() {
<span class="nc bnc" id="L1743" title="All 2 branches missed.">            if (lastReturnedNode == null) {</span>
<span class="nc" id="L1744">                throw new IllegalStateException(</span>
                        &quot;Iterator getKey() can only be called after next() and before remove()&quot;);
            }
<span class="nc" id="L1747">            return lastReturnedNode.getKey();</span>
        }

        @Override
        public V getValue() {
<span class="nc bnc" id="L1752" title="All 2 branches missed.">            if (lastReturnedNode == null) {</span>
<span class="nc" id="L1753">                throw new IllegalStateException(</span>
                        &quot;Iterator getValue() can only be called after next() and before remove()&quot;);
            }
<span class="nc" id="L1756">            return lastReturnedNode.getValue();</span>
        }

        @Override
        public V setValue(final V obj) {
<span class="nc" id="L1761">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public K next() {
<span class="nc" id="L1766">            return navigateNext().getKey();</span>
        }

        @Override
        public K previous() {
<span class="nc" id="L1771">            return navigatePrevious().getKey();</span>
        }
    }

    /**
     * An iterator over the map.
     */
    class InverseViewMapIterator extends ViewIterator implements OrderedMapIterator&lt;V, K&gt; {

        /**
         * Create a new TreeBidiMap.InverseViewMapIterator.
         */
<span class="nc" id="L1783">        public InverseViewMapIterator(final DataElement orderType) {</span>
<span class="nc" id="L1784">            super(orderType);</span>
<span class="nc" id="L1785">        }</span>

        @Override
        public V getKey() {
<span class="nc bnc" id="L1789" title="All 2 branches missed.">            if (lastReturnedNode == null) {</span>
<span class="nc" id="L1790">                throw new IllegalStateException(</span>
                        &quot;Iterator getKey() can only be called after next() and before remove()&quot;);
            }
<span class="nc" id="L1793">            return lastReturnedNode.getValue();</span>
        }

        @Override
        public K getValue() {
<span class="nc bnc" id="L1798" title="All 2 branches missed.">            if (lastReturnedNode == null) {</span>
<span class="nc" id="L1799">                throw new IllegalStateException(</span>
                        &quot;Iterator getValue() can only be called after next() and before remove()&quot;);
            }
<span class="nc" id="L1802">            return lastReturnedNode.getKey();</span>
        }

        @Override
        public K setValue(final K obj) {
<span class="nc" id="L1807">            throw new UnsupportedOperationException();</span>
        }

        @Override
        public V next() {
<span class="nc" id="L1812">            return navigateNext().getValue();</span>
        }

        @Override
        public V previous() {
<span class="nc" id="L1817">            return navigatePrevious().getValue();</span>
        }
    }

    /**
     * An iterator over the map entries.
     */
    class ViewMapEntryIterator extends ViewIterator implements OrderedIterator&lt;Entry&lt;K, V&gt;&gt; {

        /**
         * Constructor.
         */
<span class="nc" id="L1829">        ViewMapEntryIterator() {</span>
<span class="nc" id="L1830">            super(DataElement.KEY);</span>
<span class="nc" id="L1831">        }</span>

        @Override
        public Entry&lt;K, V&gt; next() {
<span class="nc" id="L1835">            return navigateNext();</span>
        }

        @Override
        public Entry&lt;K, V&gt; previous() {
<span class="nc" id="L1840">            return navigatePrevious();</span>
        }
    }

    /**
     * An iterator over the inverse map entries.
     */
    class InverseViewMapEntryIterator extends ViewIterator implements OrderedIterator&lt;Entry&lt;V, K&gt;&gt; {

        /**
         * Constructor.
         */
<span class="nc" id="L1852">        InverseViewMapEntryIterator() {</span>
<span class="nc" id="L1853">            super(DataElement.VALUE);</span>
<span class="nc" id="L1854">        }</span>

        @Override
        public Entry&lt;V, K&gt; next() {
<span class="nc" id="L1858">            return createEntry(navigateNext());</span>
        }

        @Override
        public Entry&lt;V, K&gt; previous() {
<span class="nc" id="L1863">            return createEntry(navigatePrevious());</span>
        }

        private Entry&lt;V, K&gt; createEntry(final Node&lt;K, V&gt; node) {
<span class="nc" id="L1867">            return new UnmodifiableMapEntry&lt;&gt;(node.getValue(), node.getKey());</span>
        }
    }

    //-----------------------------------------------------------------------
    //-----------------------------------------------------------------------
    /**
     * A node used to store the data.
     */
    static class Node&lt;K extends Comparable&lt;K&gt;, V extends Comparable&lt;V&gt;&gt; implements Entry&lt;K, V&gt;, KeyValue&lt;K, V&gt; {

        private final K key;
        private final V value;
        private final Node&lt;K, V&gt;[] leftNode;
        private final Node&lt;K, V&gt;[] rightNode;
        private final Node&lt;K, V&gt;[] parentNode;
        private final boolean[] blackColor;
        private int hashcodeValue;
        private boolean calculatedHashCode;

        /**
         * Make a new cell with given key and value, and with null
         * links, and black (true) colors.
         *
         * @param key the key of this node
         * @param value the value of this node
         */
        @SuppressWarnings(&quot;unchecked&quot;)
        Node(final K key, final V value) {
<span class="nc" id="L1896">            super();</span>
<span class="nc" id="L1897">            this.key = key;</span>
<span class="nc" id="L1898">            this.value = value;</span>
<span class="nc" id="L1899">            leftNode = new Node[2];</span>
<span class="nc" id="L1900">            rightNode = new Node[2];</span>
<span class="nc" id="L1901">            parentNode = new Node[2];</span>
<span class="nc" id="L1902">            blackColor = new boolean[] { true, true };</span>
<span class="nc" id="L1903">            calculatedHashCode = false;</span>
<span class="nc" id="L1904">        }</span>

        private Object getData(final DataElement dataElement) {
<span class="nc bnc" id="L1907" title="All 3 branches missed.">            switch (dataElement) {</span>
            case KEY:
<span class="nc" id="L1909">                return getKey();</span>
            case VALUE:
<span class="nc" id="L1911">                return getValue();</span>
            default:
<span class="nc" id="L1913">                throw new IllegalArgumentException();</span>
            }
        }

        private void setLeft(final Node&lt;K, V&gt; node, final DataElement dataElement) {
<span class="nc" id="L1918">            leftNode[dataElement.ordinal()] = node;</span>
<span class="nc" id="L1919">        }</span>

        private Node&lt;K, V&gt; getLeft(final DataElement dataElement) {
<span class="nc" id="L1922">            return leftNode[dataElement.ordinal()];</span>
        }

        private void setRight(final Node&lt;K, V&gt; node, final DataElement dataElement) {
<span class="nc" id="L1926">            rightNode[dataElement.ordinal()] = node;</span>
<span class="nc" id="L1927">        }</span>

        private Node&lt;K, V&gt; getRight(final DataElement dataElement) {
<span class="nc" id="L1930">            return rightNode[dataElement.ordinal()];</span>
        }

        /**
         * Set this node's parent node.
         *
         * @param node  the new parent node
         * @param dataElement  either {@link DataElement#KEY} key}
         *                     or the {@link DataElement#VALUE value}.
         */
        private void setParent(final Node&lt;K, V&gt; node, final DataElement dataElement) {
<span class="nc" id="L1941">            parentNode[dataElement.ordinal()] = node;</span>
<span class="nc" id="L1942">        }</span>

        /**
         * Get the parent node.
         *
         * @param dataElement  either {@link DataElement#KEY} key}
         *                     or the {@link DataElement#VALUE value}.
         * @return the parent node, may be null
         */
        private Node&lt;K, V&gt; getParent(final DataElement dataElement) {
<span class="nc" id="L1952">            return parentNode[dataElement.ordinal()];</span>
        }

        /**
         * Exchange colors with another node.
         *
         * @param node  the node to swap with
         * @param dataElement  either {@link DataElement#KEY} key}
         *                     or the {@link DataElement#VALUE value}.
         */
        private void swapColors(final Node&lt;K, V&gt; node, final DataElement dataElement) {
            // Swap colors -- old hacker's trick
<span class="nc" id="L1964">            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];</span>
<span class="nc" id="L1965">            node.blackColor[dataElement.ordinal()] ^= blackColor[dataElement.ordinal()];</span>
<span class="nc" id="L1966">            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];</span>
<span class="nc" id="L1967">        }</span>

        /**
         * Is this node black?
         *
         * @param dataElement  either {@link DataElement#KEY} key}
         *                     or the {@link DataElement#VALUE value}.
         * @return true if black (which is represented as a true boolean)
         */
        private boolean isBlack(final DataElement dataElement) {
<span class="nc" id="L1977">            return blackColor[dataElement.ordinal()];</span>
        }

        /**
         * Is this node red?
         *
         * @param dataElement  either {@link DataElement#KEY} key}
         *                     or the {@link DataElement#VALUE value}.
         * @return true if non-black
         */
        private boolean isRed(final DataElement dataElement) {
<span class="nc bnc" id="L1988" title="All 2 branches missed.">            return !blackColor[dataElement.ordinal()];</span>
        }

        /**
         * Make this node black.
         *
         * @param dataElement  either {@link DataElement#KEY} key}
         *                     or the {@link DataElement#VALUE value}.
         */
        private void setBlack(final DataElement dataElement) {
<span class="nc" id="L1998">            blackColor[dataElement.ordinal()] = true;</span>
<span class="nc" id="L1999">        }</span>

        /**
         * Make this node red.
         *
         * @param dataElement  either {@link DataElement#KEY} key}
         *                     or the {@link DataElement#VALUE value}.
         */
        private void setRed(final DataElement dataElement) {
<span class="nc" id="L2008">            blackColor[dataElement.ordinal()] = false;</span>
<span class="nc" id="L2009">        }</span>

        /**
         * Make this node the same color as another
         *
         * @param node  the node whose color we're adopting
         * @param dataElement  either {@link DataElement#KEY} key}
         *                     or the {@link DataElement#VALUE value}.
         */
        private void copyColor(final Node&lt;K, V&gt; node, final DataElement dataElement) {
<span class="nc" id="L2019">            blackColor[dataElement.ordinal()] = node.blackColor[dataElement.ordinal()];</span>
<span class="nc" id="L2020">        }</span>

        private boolean isLeftChild(final DataElement dataElement) {
<span class="nc bnc" id="L2023" title="All 2 branches missed.">            return parentNode[dataElement.ordinal()] != null</span>
<span class="nc bnc" id="L2024" title="All 2 branches missed.">                    &amp;&amp; parentNode[dataElement.ordinal()].leftNode[dataElement.ordinal()] == this;</span>
        }

        private boolean isRightChild(final DataElement dataElement) {
<span class="nc bnc" id="L2028" title="All 2 branches missed.">            return parentNode[dataElement.ordinal()] != null</span>
<span class="nc bnc" id="L2029" title="All 2 branches missed.">                    &amp;&amp; parentNode[dataElement.ordinal()].rightNode[dataElement.ordinal()] == this;</span>
        }

        //-------------------------------------------------------------------
        /**
         * Gets the key.
         *
         * @return the key corresponding to this entry.
         */
        @Override
        public K getKey() {
<span class="nc" id="L2040">            return key;</span>
        }

        /**
         * Gets the value.
         *
         * @return the value corresponding to this entry.
         */
        @Override
        public V getValue() {
<span class="nc" id="L2050">            return value;</span>
        }

        /**
         * Optional operation that is not permitted in this implementation
         *
         * @param ignored this parameter is ignored.
         * @return does not return
         * @throws UnsupportedOperationException always
         */
        @Override
        public V setValue(final V ignored) throws UnsupportedOperationException {
<span class="nc" id="L2062">            throw new UnsupportedOperationException(&quot;Map.Entry.setValue is not supported&quot;);</span>
        }

        /**
         * Compares the specified object with this entry for equality.
         * Returns true if the given object is also a map entry and
         * the two entries represent the same mapping.
         *
         * @param obj  the object to be compared for equality with this entry.
         * @return true if the specified object is equal to this entry.
         */
        @Override
        public boolean equals(final Object obj) {
<span class="nc bnc" id="L2075" title="All 2 branches missed.">            if (obj == this) {</span>
<span class="nc" id="L2076">                return true;</span>
            }
<span class="nc bnc" id="L2078" title="All 2 branches missed.">            if (!(obj instanceof Map.Entry)) {</span>
<span class="nc" id="L2079">                return false;</span>
            }
<span class="nc" id="L2081">            final Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;) obj;</span>
<span class="nc bnc" id="L2082" title="All 4 branches missed.">            return getKey().equals(e.getKey()) &amp;&amp; getValue().equals(e.getValue());</span>
        }

        /**
         * @return the hash code value for this map entry.
         */
        @Override
        public int hashCode() {
<span class="nc bnc" id="L2090" title="All 2 branches missed.">            if (!calculatedHashCode) {</span>
<span class="nc" id="L2091">                hashcodeValue = getKey().hashCode() ^ getValue().hashCode();</span>
<span class="nc" id="L2092">                calculatedHashCode = true;</span>
            }
<span class="nc" id="L2094">            return hashcodeValue;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * The inverse map implementation.
     */
<span class="nc" id="L2102">    class Inverse implements OrderedBidiMap&lt;V, K&gt; {</span>

        /** Store the keySet once created. */
        private Set&lt;V&gt; inverseKeySet;
        /** Store the valuesSet once created. */
        private Set&lt;K&gt; inverseValuesSet;
        /** Store the entrySet once created. */
        private Set&lt;Entry&lt;V, K&gt;&gt; inverseEntrySet;

        @Override
        public int size() {
<span class="nc" id="L2113">            return TreeBidiMap.this.size();</span>
        }

        @Override
        public boolean isEmpty() {
<span class="nc" id="L2118">            return TreeBidiMap.this.isEmpty();</span>
        }

        @Override
        public K get(final Object key) {
<span class="nc" id="L2123">            return TreeBidiMap.this.getKey(key);</span>
        }

        @Override
        public V getKey(final Object value) {
<span class="nc" id="L2128">            return TreeBidiMap.this.get(value);</span>
        }

        @Override
        public boolean containsKey(final Object key) {
<span class="nc" id="L2133">            return TreeBidiMap.this.containsValue(key);</span>
        }

        @Override
        public boolean containsValue(final Object value) {
<span class="nc" id="L2138">            return TreeBidiMap.this.containsKey(value);</span>
        }

        @Override
        public V firstKey() {
<span class="nc bnc" id="L2143" title="All 2 branches missed.">            if (TreeBidiMap.this.nodeCount == 0) {</span>
<span class="nc" id="L2144">                throw new NoSuchElementException(&quot;Map is empty&quot;);</span>
            }
<span class="nc" id="L2146">            return leastNode(TreeBidiMap.this.rootNode[DataElement.VALUE.ordinal()], DataElement.VALUE).getValue();</span>
        }

        @Override
        public V lastKey() {
<span class="nc bnc" id="L2151" title="All 2 branches missed.">            if (TreeBidiMap.this.nodeCount == 0) {</span>
<span class="nc" id="L2152">                throw new NoSuchElementException(&quot;Map is empty&quot;);</span>
            }
<span class="nc" id="L2154">            return greatestNode(TreeBidiMap.this.rootNode[DataElement.VALUE.ordinal()], DataElement.VALUE).getValue();</span>
        }

        @Override
        public V nextKey(final V key) {
<span class="nc" id="L2159">            checkKey(key);</span>
<span class="nc" id="L2160">            final Node&lt;K, V&gt; node = nextGreater(TreeBidiMap.this.&lt;V&gt;lookup(key, DataElement.VALUE), DataElement.VALUE);</span>
<span class="nc bnc" id="L2161" title="All 2 branches missed.">            return node == null ? null : node.getValue();</span>
        }

        @Override
        public V previousKey(final V key) {
<span class="nc" id="L2166">            checkKey(key);</span>
<span class="nc" id="L2167">            final Node&lt;K, V&gt; node = TreeBidiMap.this.nextSmaller(TreeBidiMap.this.&lt;V&gt;lookup(key, DataElement.VALUE), DataElement.VALUE);</span>
<span class="nc bnc" id="L2168" title="All 2 branches missed.">            return node == null ? null : node.getValue();</span>
        }

        @Override
        public K put(final V key, final K value) {
<span class="nc" id="L2173">            final K result = get(key);</span>
<span class="nc" id="L2174">            TreeBidiMap.this.doPut(value, key);</span>
<span class="nc" id="L2175">            return result;</span>
        }

        @Override
        public void putAll(final Map&lt;? extends V, ? extends K&gt; map) {
<span class="nc bnc" id="L2180" title="All 2 branches missed.">            for (final Entry&lt;? extends V, ? extends K&gt; e : map.entrySet()) {</span>
<span class="nc" id="L2181">                put(e.getKey(), e.getValue());</span>
<span class="nc" id="L2182">            }</span>
<span class="nc" id="L2183">        }</span>

        @Override
        public K remove(final Object key) {
<span class="nc" id="L2187">            return TreeBidiMap.this.removeValue(key);</span>
        }

        @Override
        public V removeValue(final Object value) {
<span class="nc" id="L2192">            return TreeBidiMap.this.remove(value);</span>
        }

        @Override
        public void clear() {
<span class="nc" id="L2197">            TreeBidiMap.this.clear();</span>
<span class="nc" id="L2198">        }</span>

        @Override
        public Set&lt;V&gt; keySet() {
<span class="nc bnc" id="L2202" title="All 2 branches missed.">            if (inverseKeySet == null) {</span>
<span class="nc" id="L2203">                inverseKeySet = new ValueView(DataElement.VALUE);</span>
            }
<span class="nc" id="L2205">            return inverseKeySet;</span>
        }

        @Override
        public Set&lt;K&gt; values() {
<span class="nc bnc" id="L2210" title="All 2 branches missed.">            if (inverseValuesSet == null) {</span>
<span class="nc" id="L2211">                inverseValuesSet = new KeyView(DataElement.VALUE);</span>
            }
<span class="nc" id="L2213">            return inverseValuesSet;</span>
        }

        @Override
        public Set&lt;Entry&lt;V, K&gt;&gt; entrySet() {
<span class="nc bnc" id="L2218" title="All 2 branches missed.">            if (inverseEntrySet == null) {</span>
<span class="nc" id="L2219">                inverseEntrySet = new InverseEntryView();</span>
            }
<span class="nc" id="L2221">            return inverseEntrySet;</span>
        }

        @Override
        public OrderedMapIterator&lt;V, K&gt; mapIterator() {
<span class="nc bnc" id="L2226" title="All 2 branches missed.">            if (isEmpty()) {</span>
<span class="nc" id="L2227">                return EmptyOrderedMapIterator.&lt;V, K&gt;emptyOrderedMapIterator();</span>
            }
<span class="nc" id="L2229">            return new InverseViewMapIterator(DataElement.VALUE);</span>
        }

        @Override
        public OrderedBidiMap&lt;K, V&gt; inverseBidiMap() {
<span class="nc" id="L2234">            return TreeBidiMap.this;</span>
        }

        @Override
        public boolean equals(final Object obj) {
<span class="nc" id="L2239">            return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L2244">            return TreeBidiMap.this.doHashCode(DataElement.VALUE);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L2249">            return TreeBidiMap.this.doToString(DataElement.VALUE);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>