<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>Graph.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-lib</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.lib.graph</a> &gt; <span class="el_source">Graph.java</span></div><h1>Graph.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.lib.graph;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * &lt;p&gt;Graph representation using the adjacency list form.  See the book
 * 'Introduction to Algorithms' by Cormen, Leiserson, and Rivest.&lt;/p&gt;
 *
 * @author Abe White
 * @since 1.0.0
 */
<span class="fc" id="L35">public class Graph {</span>

    /**
     * Map each node to list of edges from that node.
     * Using a LinkedHashMap to ensure order of iterator processing.
     */
<span class="fc" id="L41">    private final Map&lt;Object, Collection&lt;Edge&gt;&gt; _nodes = new LinkedHashMap&lt;&gt;();</span>

    /**
     * Clear the graph.
     */
    public void clear() {
<span class="fc" id="L47">        _nodes.clear();</span>
<span class="fc" id="L48">    }</span>

    /**
     * Return true if the graph contains the given node.
     */
    public boolean containsNode(Object node) {
<span class="fc" id="L54">        return _nodes.containsKey(node);</span>
    }

    /**
     * Return a view of all nodes in the graph.
     */
    public Collection&lt;Object&gt; getNodes() {
<span class="fc" id="L61">        return _nodes.keySet();</span>
    }

    /**
     * Add a node to the graph.  Adding a node a second time has no effect.
     */
    public void addNode(Object node) {
<span class="fc bfc" id="L68" title="All 2 branches covered.">        if (node == null)</span>
<span class="fc" id="L69">            throw new NullPointerException(&quot;node = null&quot;);</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">        if (!containsNode(node))</span>
<span class="fc" id="L71">            _nodes.put(node, null);</span>
<span class="fc" id="L72">    }</span>

    /**
     * Remove a node from the graph.  All edges to and from the node
     * will be cleared.
     *
     * @return true if the node was removed, false otherwise
     */
    public boolean removeNode(Object node) {
<span class="fc" id="L81">        boolean rem = containsNode(node);</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">        if (rem) {</span>
<span class="fc" id="L83">            Collection&lt;Edge&gt; edges = getEdgesTo(node);</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">            for (Edge edge : edges)</span>
<span class="fc" id="L85">                removeEdge( edge);</span>
<span class="fc" id="L86">            _nodes.remove(node);</span>
        }
<span class="fc" id="L88">        return rem;</span>
    }

    /**
     * Return all edges in the graph.
     */
    public Collection&lt;Edge&gt; getEdges() {
<span class="fc" id="L95">        Collection&lt;Edge&gt; all = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">        for (Collection&lt;Edge&gt; edges : _nodes.values()) {</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        	if (edges != null)</span>
<span class="fc" id="L98">        		all.addAll(edges);</span>
<span class="fc" id="L99">        }</span>
<span class="fc" id="L100">        return all;</span>
    }

    /**
     * Return all the edges from a particular node.
     */
    public Collection&lt;Edge&gt; getEdgesFrom(Object node) {
<span class="fc" id="L107">        Collection&lt;Edge&gt; edges = _nodes.get(node);</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        if(edges == null ) {</span>
<span class="fc" id="L109">            edges = Collections.emptyList();</span>
        }
<span class="fc" id="L111">        return edges;</span>
    }

    /**
     * Return all the edges to a particular node.
     */
    public Collection&lt;Edge&gt; getEdgesTo(Object node) {
<span class="fc" id="L118">    	Collection&lt;Edge&gt; edges = getEdges();</span>
<span class="fc" id="L119">    	Collection&lt;Edge&gt; to = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">    	for (Edge edge : edges) {</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">    		if (edge.isTo(node))</span>
<span class="fc" id="L122">    			to.add(edge);</span>
<span class="fc" id="L123">    	}</span>
<span class="fc" id="L124">    	return to;</span>
    }

    /**
     * Return all the edges from one node to another.
     */
    public Collection&lt;Edge&gt; getEdges(Object from, Object to) {
<span class="nc" id="L131">        Collection&lt;Edge&gt; edges = getEdgesFrom(from);</span>
<span class="nc" id="L132">        Collection&lt;Edge&gt; matches = new ArrayList&lt;&gt;(edges.size());</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">        for (Edge edge : edges) {</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">            if (edge.isTo(to))</span>
<span class="nc" id="L135">                matches.add(edge);</span>
<span class="nc" id="L136">        }</span>
<span class="nc" id="L137">        return matches;</span>
    }

    /**
     * Add an edge to the graph.
     */
    public void addEdge(Edge edge) {
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (!containsNode(edge.getTo()))</span>
<span class="fc" id="L145">            throw new IllegalArgumentException(edge.getTo().toString());</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (!containsNode(edge.getFrom()))</span>
<span class="fc" id="L147">            throw new IllegalArgumentException(edge.getFrom().toString());</span>

<span class="fc" id="L149">        Collection&lt;Edge&gt; from = _nodes.computeIfAbsent(edge.getFrom(), k -&gt; new ArrayList&lt;&gt;(3));</span>
<span class="fc" id="L150">        from.add(edge);</span>

<span class="fc bfc" id="L152" title="All 4 branches covered.">        if (!edge.isDirected() &amp;&amp; !edge.getFrom().equals(edge.getTo())) {</span>
<span class="fc" id="L153">            Collection&lt;Edge&gt; to = _nodes.computeIfAbsent(edge.getTo(), k -&gt; new ArrayList&lt;&gt;(3));</span>
<span class="fc" id="L154">            to.add(edge);</span>
        }
<span class="fc" id="L156">    }</span>

    /**
     * Remove an edge from the graph.
     *
     * @return true if the edge was removed, false if not in the graph
     */
    public boolean removeEdge(Edge edge) {
<span class="fc" id="L164">        Collection&lt;Edge&gt; edges = _nodes.get(edge.getFrom());</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (edges == null)</span>
<span class="fc" id="L166">            return false;</span>
<span class="fc" id="L167">        boolean rem = edges.remove(edge);</span>
<span class="fc bfc" id="L168" title="All 4 branches covered.">        if (rem &amp;&amp; !edge.isDirected()) {</span>
<span class="fc" id="L169">            edges = _nodes.get(edge.getTo());</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">            if (edges != null)</span>
<span class="fc" id="L171">                edges.remove(edge);</span>
        }
<span class="fc" id="L173">        return rem;</span>
    }

    /**
     *	Clear all nodes and edges of the bookkeeping information from their
     *	last traversal.
     */
    public void clearTraversal() {
<span class="nc bnc" id="L181" title="All 2 branches missed.">    	for (Collection&lt;Edge&gt; edges : _nodes.values()) {</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">    		if (edges != null)</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">    			for (Edge edge : edges)</span>
<span class="nc" id="L184">    				edge.clearTraversal();</span>
<span class="nc" id="L185">    	}</span>
<span class="nc" id="L186">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>