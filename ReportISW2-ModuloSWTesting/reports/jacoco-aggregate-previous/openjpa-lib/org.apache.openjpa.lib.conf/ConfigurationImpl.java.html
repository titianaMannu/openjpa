<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ConfigurationImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">tests</a> &gt; <a href="../index.html" class="el_bundle">openjpa-lib</a> &gt; <a href="index.source.html" class="el_package">org.apache.openjpa.lib.conf</a> &gt; <span class="el_source">ConfigurationImpl.java</span></div><h1>ConfigurationImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.openjpa.lib.conf;

import java.awt.Image;
import java.beans.BeanDescriptor;
import java.beans.BeanInfo;
import java.beans.EventSetDescriptor;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.MethodDescriptor;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.PropertyDescriptor;
import java.io.Externalizable;
import java.io.File;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.PrintWriter;
import java.io.Serializable;
import java.io.StringWriter;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.AccessController;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Objects;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

import org.apache.openjpa.lib.log.Log;
import org.apache.openjpa.lib.log.LogFactory;
import org.apache.openjpa.lib.log.LogFactoryImpl;
import org.apache.openjpa.lib.log.NoneLogFactory;
import org.apache.openjpa.lib.util.Closeable;
import org.apache.openjpa.lib.util.J2DoPrivHelper;
import org.apache.openjpa.lib.util.Localizer;
import org.apache.openjpa.lib.util.MultiClassLoader;
import org.apache.openjpa.lib.util.ParseException;
import org.apache.openjpa.lib.util.Services;
import org.apache.openjpa.lib.util.StringDistance;
import org.apache.openjpa.lib.util.StringUtil;

/**
 * Default implementation of the {@link Configuration} interface.
 * Subclasses can choose to obtain configuration
 * information from JNDI, Properties, a Bean-builder, etc. This class
 * provides base configuration functionality, including serialization,
 * the &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;hashCode&lt;/code&gt; contracts, and default
 * property loading.
 * Property descriptors for {@link Value} instances are constructed from
 * the {@link Localizer} for the package of the configuration class. The
 * following localized strings will be used for describing a value, where
 * &lt;em&gt;name&lt;/em&gt; is the last token of the value's property string:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;em&gt;name&lt;/em&gt;-name: The name that will be displayed for the
 * option in a user interface; required.&lt;/li&gt;
 * &lt;li&gt;&lt;em&gt;name&lt;/em&gt;-desc: A brief description of the option; required.&lt;/li&gt;
 * &lt;li&gt;&lt;em&gt;name&lt;/em&gt;-type: The type or category name for this option;
 * required.&lt;/li&gt;
 * &lt;li&gt;&lt;em&gt;name&lt;/em&gt;-expert: True if this is an expert option, false
 * otherwise; defaults to false.&lt;/li&gt;
 * &lt;li&gt;&lt;em&gt;name&lt;/em&gt;-values: Set of expected or common values, excluding
 * alias keys; optional.&lt;/li&gt;
 * &lt;li&gt;&lt;em&gt;name&lt;/em&gt;-interface: The class name of an interface whose
 * discoverable implementations should be included in the set of expected
 * or common values; optional.&lt;/li&gt;
 * &lt;li&gt;&lt;em&gt;name&lt;/em&gt;-cat: The hierarchical category for the property
 * name, separated by &quot;.&quot;.
 * &lt;li&gt;&lt;em&gt;name&lt;/em&gt;-displayorder: The order in which the property should
 * be displayer.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Abe White
 */
public class ConfigurationImpl
    implements Configuration, Externalizable, ValueListener {

<span class="nc" id="L107">    private static final String SEP = J2DoPrivHelper.getLineSeparator();</span>

<span class="nc" id="L109">    private static final Localizer _loc = Localizer.forPackage(ConfigurationImpl.class);</span>

    public ObjectValue logFactoryPlugin;
    public StringValue id;

<span class="nc" id="L114">    private String _product = null;</span>
<span class="nc" id="L115">    private int _readOnlyState = INIT_STATE_LIQUID;</span>
<span class="nc" id="L116">    private Map _props = null;</span>
<span class="nc" id="L117">    private boolean _globals = false;</span>
<span class="nc" id="L118">    private String _auto = null;</span>
<span class="nc" id="L119">    private final List&lt;Value&gt; _vals = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L120">    private Set&lt;String&gt; _supportedKeys = new TreeSet&lt;&gt;();</span>

    // property listener helper
<span class="nc" id="L123">    private PropertyChangeSupport _changeSupport = null;</span>

    // cache descriptors
<span class="nc" id="L126">    private PropertyDescriptor[] _pds = null;</span>
<span class="nc" id="L127">    private MethodDescriptor[] _mds = null;</span>

    // An additional (and optional) classloader to load custom plugins.
    private ClassLoader _userCL;

    //Ant task needs to defer the resource loading
    //until the classpath setting is loaded properly
<span class="nc" id="L134">    private boolean _deferResourceLoading = false;</span>


    /**
     * Default constructor. Attempts to load default properties through
     * system's configured {@link ProductDerivation}s.
     */
    public ConfigurationImpl() {
<span class="nc" id="L142">        this(true);</span>
<span class="nc" id="L143">    }</span>

    /**
     * Constructor.
     *
     * @param loadGlobals whether to attempt to load the global properties
     */
<span class="nc" id="L150">    public ConfigurationImpl(boolean loadGlobals) {</span>
<span class="nc" id="L151">        setProductName(&quot;openjpa&quot;);</span>

<span class="nc" id="L153">        logFactoryPlugin = addPlugin(&quot;Log&quot;, true);</span>
<span class="nc" id="L154">        String[] aliases = new String[]{</span>
<span class="nc" id="L155">            &quot;true&quot;, LogFactoryImpl.class.getName(),</span>
<span class="nc" id="L156">            &quot;openjpa&quot;, LogFactoryImpl.class.getName(),</span>
            &quot;commons&quot;, &quot;org.apache.openjpa.lib.log.CommonsLogFactory&quot;,
            &quot;log4j&quot;, &quot;org.apache.openjpa.lib.log.Log4JLogFactory&quot;,
            &quot;log4j2&quot;, &quot;org.apache.openjpa.lib.log.Log4J2LogFactory&quot;,
            &quot;slf4j&quot;, &quot;org.apache.openjpa.lib.log.SLF4JLogFactory&quot;,
            &quot;jul&quot;, &quot;org.apache.openjpa.lib.log.JULLogFactory&quot;,
<span class="nc" id="L162">            &quot;none&quot;, NoneLogFactory.class.getName(),</span>
<span class="nc" id="L163">            &quot;false&quot;, NoneLogFactory.class.getName(),</span>
        };
<span class="nc" id="L165">        logFactoryPlugin.setAliases(aliases);</span>
<span class="nc" id="L166">        logFactoryPlugin.setDefault(aliases[0]);</span>
<span class="nc" id="L167">        logFactoryPlugin.setString(aliases[0]);</span>
<span class="nc" id="L168">        logFactoryPlugin.setInstantiatingGetter(&quot;getLogFactory&quot;);</span>

<span class="nc" id="L170">        id = addString(&quot;Id&quot;);</span>

<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (loadGlobals)</span>
<span class="nc" id="L173">            loadGlobals();</span>
<span class="nc" id="L174">    }</span>

    /**
     * Automatically load global values from the system's
     * {@link ProductDerivation}s, and from System properties.
     */
    public boolean loadGlobals() {
        MultiClassLoader loader = AccessController
<span class="nc" id="L182">            .doPrivileged(J2DoPrivHelper.newMultiClassLoaderAction());</span>
<span class="nc" id="L183">        loader.addClassLoader(AccessController.doPrivileged(</span>
<span class="nc" id="L184">            J2DoPrivHelper.getContextClassLoaderAction()));</span>
<span class="nc" id="L185">        loader.addClassLoader(getClass().getClassLoader());</span>
<span class="nc" id="L186">        ConfigurationProvider provider = ProductDerivations.loadGlobals(loader);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (provider != null)</span>
<span class="nc" id="L188">            provider.setInto(this);</span>

        // let system properties override other globals
        try {
<span class="nc" id="L192">            Properties systemProperties = AccessController.doPrivileged(</span>
<span class="nc" id="L193">                    J2DoPrivHelper.getPropertiesAction());</span>
<span class="nc" id="L194">            HashMap sysPropHM = null;</span>
<span class="nc" id="L195">            synchronized(systemProperties) {</span>
                // Prevent concurrent modification of systemProperties until HashMap ctor is completed.
<span class="nc" id="L197">                sysPropHM = new HashMap(systemProperties);</span>
<span class="nc" id="L198">            }</span>
<span class="nc" id="L199">            fromProperties(sysPropHM);</span>
<span class="nc" id="L200">        } catch (SecurityException se) {</span>
            // security manager might disallow
<span class="nc" id="L202">        }</span>

<span class="nc" id="L204">        _globals = true;</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (provider == null) {</span>
<span class="nc" id="L206">            Log log = getConfigurationLog();</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (log.isTraceEnabled())</span>
<span class="nc" id="L208">                log.trace(_loc.get(&quot;no-default-providers&quot;));</span>
<span class="nc" id="L209">            return false;</span>
        }
<span class="nc" id="L211">        return true;</span>
    }

    @Override
    public String getProductName() {
<span class="nc" id="L216">        return _product;</span>
    }

    @Override
    public void setProductName(String name) {
<span class="nc" id="L221">        _product = name;</span>
<span class="nc" id="L222">    }</span>

    @Override
    public LogFactory getLogFactory() {
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (logFactoryPlugin.get() == null)</span>
<span class="nc" id="L227">            logFactoryPlugin.instantiate(LogFactory.class, this);</span>
<span class="nc" id="L228">        return (LogFactory) logFactoryPlugin.get();</span>
    }

    @Override
    public void setLogFactory(LogFactory logFactory) {
<span class="nc" id="L233">        logFactoryPlugin.set(logFactory);</span>
<span class="nc" id="L234">    }</span>

    @Override
    public String getLog() {
<span class="nc" id="L238">        return logFactoryPlugin.getString();</span>
    }

    @Override
    public void setLog(String log) {
<span class="nc" id="L243">        logFactoryPlugin.setString(log);</span>
<span class="nc" id="L244">    }</span>

    @Override
    public Log getLog(String category) {
<span class="nc" id="L248">        return getLogFactory().getLog(category);</span>
    }

    @Override
    public String getId() {
<span class="nc" id="L253">        return id.get();</span>
    }

    @Override
    public void setId(String id) {
<span class="nc" id="L258">        this.id.set(id);</span>
<span class="nc" id="L259">    }</span>

    /**
     * Returns the logging channel &lt;code&gt;openjpa.Runtime&lt;/code&gt; by default.
     */
    @Override
    public Log getConfigurationLog() {
<span class="nc" id="L266">        return getLog(&quot;openjpa.Runtime&quot;);</span>
    }

    @Override
    public Value[] getValues() {
<span class="nc" id="L271">        return (Value[]) _vals.toArray(new Value[_vals.size()]);</span>
    }

    /**
     * Gets the registered Value for the given propertyName.
     *
     * @param property can be either fully-qualified name or the simple name
     * with which the value has been registered. A value may have multiple
     * equivalent names and this method searches with all equivalent names.
     */
    @Override
    public Value getValue(String property) {
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (property == null)</span>
<span class="nc" id="L284">            return null;</span>

        // search backwards so that custom values added after construction
        // are found quickly, since this will be the std way of accessing them
<span class="nc bnc" id="L288" title="All 2 branches missed.">        for (int i = _vals.size()-1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">            if (_vals.get(i).matches(property))</span>
<span class="nc" id="L290">                return _vals.get(i);</span>
        }
<span class="nc" id="L292">        return null;</span>
    }

    @Override
    public void setReadOnly(int newState) {
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (newState &gt;= _readOnlyState) {</span>
<span class="nc" id="L298">        	_readOnlyState = newState;</span>
        }
<span class="nc" id="L300">    }</span>

    public boolean isDeferResourceLoading() {
<span class="nc" id="L303">        return _deferResourceLoading;</span>
    }

    public void setDeferResourceLoading(boolean deferResourceLoading) {
<span class="nc" id="L307">        this._deferResourceLoading = deferResourceLoading;</span>
<span class="nc" id="L308">    }</span>

    @Override
    public void instantiateAll() {
<span class="nc" id="L312">        StringWriter errs = null;</span>
<span class="nc" id="L313">        PrintWriter stack = null;</span>
        String getterName;
        Method getter;
        Object getterTarget;
<span class="nc bnc" id="L317" title="All 2 branches missed.">        for(Value val : _vals) {</span>
<span class="nc" id="L318">            getterName = val.getInstantiatingGetter();</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">            if (getterName == null)</span>
<span class="nc" id="L320">                continue;</span>

<span class="nc" id="L322">            getterTarget = this;</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (getterName.startsWith(&quot;this.&quot;)) {</span>
<span class="nc" id="L324">                getterName = getterName.substring(&quot;this.&quot;.length());</span>
<span class="nc" id="L325">                getterTarget = val;</span>
            }

            try {
<span class="nc" id="L329">                getter = getterTarget.getClass().getMethod(getterName,</span>
                    (Class[]) null);
<span class="nc" id="L331">                getter.invoke(getterTarget, (Object[]) null);</span>
<span class="nc" id="L332">            } catch (Throwable t) {</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">                if (t instanceof InvocationTargetException)</span>
<span class="nc" id="L334">                    t = ((InvocationTargetException) t).getTargetException();</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">                if (errs == null) {</span>
<span class="nc" id="L336">                    errs = new StringWriter();</span>
<span class="nc" id="L337">                    stack = new PrintWriter(errs);</span>
                } else
<span class="nc" id="L339">                    errs.write(SEP);</span>
<span class="nc" id="L340">                t.printStackTrace(stack);</span>
<span class="nc" id="L341">                stack.flush();</span>
<span class="nc" id="L342">            }</span>
<span class="nc" id="L343">        }</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (errs != null)</span>
<span class="nc" id="L345">            throw new RuntimeException(_loc.get(&quot;get-prop-errs&quot;,</span>
<span class="nc" id="L346">                errs.toString()).getMessage());</span>
<span class="nc" id="L347">    }</span>

    @Override
    public boolean isReadOnly() {
<span class="nc bnc" id="L351" title="All 2 branches missed.">        return _readOnlyState==INIT_STATE_FROZEN;</span>
    }

    @Override
    public void addPropertyChangeListener(PropertyChangeListener listener) {
<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (_changeSupport == null)</span>
<span class="nc" id="L357">            _changeSupport = new PropertyChangeSupport(this);</span>
<span class="nc" id="L358">        _changeSupport.addPropertyChangeListener(listener);</span>
<span class="nc" id="L359">    }</span>

    @Override
    public void removePropertyChangeListener(PropertyChangeListener listener) {
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (_changeSupport != null)</span>
<span class="nc" id="L364">            _changeSupport.removePropertyChangeListener(listener);</span>
<span class="nc" id="L365">    }</span>

    @Override
    public void valueChanged(Value val) {
<span class="nc bnc" id="L369" title="All 4 branches missed.">        if (_changeSupport == null &amp;&amp; _props == null)</span>
<span class="nc" id="L370">            return;</span>

<span class="nc" id="L372">        String newString = val.getString();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (_changeSupport != null)</span>
<span class="nc" id="L374">            _changeSupport.firePropertyChange(val.getProperty(), null, newString);</span>

        // keep cached props up to date
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (_props != null) {</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">            if (newString == null)</span>
<span class="nc" id="L379">                Configurations.removeProperty(val.getProperty(), _props);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">            else if (Configurations.containsProperty(val, _props)</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">                || val.getDefault() == null</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">                || !val.getDefault().equals(newString))</span>
<span class="nc" id="L383">                setValue(_props, val);</span>
        }
<span class="nc" id="L385">    }</span>

    /**
     * Closes all closeable values and plugins.
     */
    @Override
    public final void close() {
<span class="nc" id="L392">        ProductDerivations.beforeClose(this);</span>

<span class="nc" id="L394">        preClose();</span>

        ObjectValue val;
<span class="nc bnc" id="L397" title="All 2 branches missed.">        for(Value v : _vals) {</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">            if (v instanceof Closeable) {</span>
                try {
<span class="nc" id="L400">                    ((Closeable)v).close();</span>
                }
<span class="nc" id="L402">                catch (Exception e) {</span>
                    // noop
<span class="nc" id="L404">                }</span>
<span class="nc" id="L405">                continue;</span>
            }

<span class="nc bnc" id="L408" title="All 2 branches missed.">            if (!(v  instanceof ObjectValue))</span>
<span class="nc" id="L409">                continue;</span>

<span class="nc" id="L411">            val = (ObjectValue) v;</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (val.get() instanceof Closeable) {</span>
                try {
<span class="nc" id="L414">                    ((Closeable) val.get()).close();</span>
<span class="nc" id="L415">                } catch (Exception e) {</span>
<span class="nc" id="L416">                }</span>
            }
<span class="nc" id="L418">        }</span>
<span class="nc" id="L419">    }</span>

    /**
     * Invoked by final method {@link #close} after invoking the
     * {@link ProductDerivation#beforeConfigurationClose} callbacks
     * but before performing internal close operations.
     *
     * @since 0.9.7
     */
    protected void preClose() {
<span class="nc" id="L429">    }</span>

    ///////////////////////////
    // BeanInfo implementation
    ///////////////////////////

    @Override
    public BeanInfo[] getAdditionalBeanInfo() {
<span class="nc" id="L437">        return new BeanInfo[0];</span>
    }

    @Override
    public BeanDescriptor getBeanDescriptor() {
<span class="nc" id="L442">        return new BeanDescriptor(getClass());</span>
    }

    @Override
    public int getDefaultEventIndex() {
<span class="nc" id="L447">        return 0;</span>
    }

    @Override
    public int getDefaultPropertyIndex() {
<span class="nc" id="L452">        return 0;</span>
    }

    @Override
    public EventSetDescriptor[] getEventSetDescriptors() {
<span class="nc" id="L457">        return new EventSetDescriptor[0];</span>
    }

    @Override
    public Image getIcon(int kind) {
<span class="nc" id="L462">        return null;</span>
    }

    @Override
    public synchronized MethodDescriptor[] getMethodDescriptors() {
<span class="nc bnc" id="L467" title="All 2 branches missed.">        if (_mds != null)</span>
<span class="nc" id="L468">            return _mds;</span>

<span class="nc" id="L470">        PropertyDescriptor[] pds = getPropertyDescriptors();</span>
<span class="nc" id="L471">        List&lt;MethodDescriptor&gt; descs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">        for (PropertyDescriptor pd : pds) {</span>
<span class="nc" id="L473">            Method write = pd.getWriteMethod();</span>
<span class="nc" id="L474">            Method read = pd.getReadMethod();</span>
<span class="nc bnc" id="L475" title="All 4 branches missed.">            if (read != null &amp;&amp; write != null) {</span>
<span class="nc" id="L476">                descs.add(new MethodDescriptor(write));</span>
<span class="nc" id="L477">                descs.add(new MethodDescriptor(read));</span>
            }
        }
<span class="nc" id="L480">        _mds = (MethodDescriptor[]) descs.</span>
<span class="nc" id="L481">            toArray(new MethodDescriptor[descs.size()]);</span>
<span class="nc" id="L482">        return _mds;</span>
    }

    @Override
    public synchronized PropertyDescriptor[] getPropertyDescriptors() {
<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (_pds != null)</span>
<span class="nc" id="L488">            return _pds;</span>

<span class="nc" id="L490">        _pds = new PropertyDescriptor[_vals.size()];</span>

<span class="nc" id="L492">        List&lt;String&gt; failures = null;</span>
        Value val;
<span class="nc bnc" id="L494" title="All 2 branches missed.">        for (int i = 0; i &lt; _vals.size(); i++) {</span>
<span class="nc" id="L495">            val = (Value) _vals.get(i);</span>
            try {
<span class="nc" id="L497">                _pds[i] = getPropertyDescriptor(val);</span>
<span class="nc" id="L498">            } catch (MissingResourceException | IntrospectionException mre) {</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">                if (failures == null)</span>
<span class="nc" id="L500">                    failures = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L501">                failures.add(val.getProperty());</span>
<span class="nc" id="L502">            }</span>
        }
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (failures != null)</span>
<span class="nc" id="L505">            throw new ParseException(_loc.get(&quot;invalid-property-descriptors&quot;,</span>
                failures));

<span class="nc" id="L508">        return _pds;</span>
    }

    /**
     * Create a property descriptor for the given value.
     */
    private PropertyDescriptor getPropertyDescriptor(Value val)
        throws IntrospectionException {
<span class="nc" id="L516">        String prop = val.getProperty();</span>
<span class="nc" id="L517">        prop = prop.substring(prop.lastIndexOf('.') + 1);</span>

        // set up property descriptor
        PropertyDescriptor pd;
        try {
<span class="nc" id="L522">            pd = new PropertyDescriptor(Introspector.decapitalize(prop),</span>
<span class="nc" id="L523">                getClass());</span>
<span class="nc" id="L524">        } catch (IntrospectionException ie) {</span>
            // if there aren't any methods for this value(i.e., if it's a
            // dynamically-added value), then an IntrospectionException will
            // be thrown. Try to create a PD with no read or write methods.
<span class="nc" id="L528">            pd = new PropertyDescriptor(Introspector.decapitalize(prop),</span>
                (Method) null, (Method) null);
<span class="nc" id="L530">        }</span>
<span class="nc" id="L531">        pd.setDisplayName(findLocalized(prop + &quot;-name&quot;, true, val.getScope()));</span>
<span class="nc" id="L532">        pd.setShortDescription(findLocalized(prop + &quot;-desc&quot;, true,</span>
<span class="nc" id="L533">            val.getScope()));</span>
<span class="nc" id="L534">        pd.setExpert(&quot;true&quot;.equals(findLocalized(prop + &quot;-expert&quot;, false,</span>
<span class="nc" id="L535">            val.getScope())));</span>

        try {
<span class="nc" id="L538">            pd.setReadMethod(getClass().getMethod(&quot;get&quot;</span>
<span class="nc" id="L539">                + StringUtil.capitalize(prop), (Class[]) null));</span>
<span class="nc" id="L540">            pd.setWriteMethod(getClass().getMethod(&quot;set&quot;</span>
<span class="nc" id="L541">                + StringUtil.capitalize(prop), new Class[]</span>
<span class="nc" id="L542">                { pd.getReadMethod().getReturnType() }));</span>
<span class="nc" id="L543">        } catch (Throwable t) {</span>
            // if an error occurs, it might be because the value is a
            // dynamic property.
<span class="nc" id="L546">        }</span>

<span class="nc" id="L548">        String type = findLocalized(prop + &quot;-type&quot;, true, val.getScope());</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">        if (type != null)</span>
<span class="nc" id="L550">            pd.setValue(ATTRIBUTE_TYPE, type);</span>

<span class="nc" id="L552">        String cat = findLocalized(prop + &quot;-cat&quot;, false, val.getScope());</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">        if (cat != null)</span>
<span class="nc" id="L554">            pd.setValue(ATTRIBUTE_CATEGORY, cat);</span>

<span class="nc" id="L556">        pd.setValue(ATTRIBUTE_XML, toXMLName(prop));</span>

<span class="nc" id="L558">        String order = findLocalized(prop + &quot;-displayorder&quot;, false,</span>
<span class="nc" id="L559">            val.getScope());</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (order != null)</span>
<span class="nc" id="L561">            pd.setValue(ATTRIBUTE_ORDER, order);</span>

        // collect allowed values from alias keys, listed values, and
        // interface implementors
<span class="nc" id="L565">        Collection&lt;String&gt; allowed = new TreeSet&lt;&gt;();</span>
<span class="nc" id="L566">        List&lt;String&gt; aliases = Collections.emptyList();</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">        if (val.getAliases() != null) {</span>
<span class="nc" id="L568">            aliases = Arrays.asList(val.getAliases());</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">            for (int i = 0; i &lt; aliases.size(); i += 2)</span>
<span class="nc" id="L570">                allowed.add(aliases.get(i));</span>
        }
<span class="nc" id="L572">        String[] vals = StringUtil.split(findLocalized(prop</span>
<span class="nc" id="L573">            + &quot;-values&quot;, false, val.getScope()), &quot;,&quot;, 0);</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">        for (String s : vals)</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">            if (!aliases.contains(s))</span>
<span class="nc" id="L576">                allowed.add(s);</span>
        try {
<span class="nc" id="L578">            Class&lt;?&gt; intf = Class.forName(findLocalized(prop</span>
<span class="nc" id="L579">                + &quot;-interface&quot;, true, val.getScope()), false,</span>
<span class="nc" id="L580">                getClass().getClassLoader());</span>
<span class="nc" id="L581">            pd.setValue(ATTRIBUTE_INTERFACE, intf.getName());</span>
<span class="nc" id="L582">            String[] impls = Services.getImplementors(intf);</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">            for (String impl : impls)</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">                if (!aliases.contains(impl))</span>
<span class="nc" id="L585">                    allowed.add(impl);</span>
<span class="nc" id="L586">        } catch (Throwable t) {</span>
<span class="nc" id="L587">        }</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">        if (!allowed.isEmpty())</span>
<span class="nc" id="L589">            pd.setValue(ATTRIBUTE_ALLOWED_VALUES, (String[]) allowed.toArray</span>
<span class="nc" id="L590">                (new String[allowed.size()]));</span>

<span class="nc" id="L592">        return pd;</span>
    }

    /**
     * Find the given localized string, or return null if not found.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private String findLocalized(String key, boolean fatal, Class&lt;?&gt; scope) {
        // find the localizer package that contains this key
<span class="nc" id="L601">        Localizer loc = null;</span>

        // check the package that the value claims to be defined in, if
        // available, before we start guessing.
<span class="nc bnc" id="L605" title="All 2 branches missed.">        if (scope != null) {</span>
<span class="nc" id="L606">            loc = Localizer.forPackage(scope);</span>
            try {
<span class="nc" id="L608">                return loc.getFatal(key).getMessage();</span>
<span class="nc" id="L609">            } catch (MissingResourceException mse) {</span>
            }
        }

<span class="nc bnc" id="L613" title="All 2 branches missed.">        for (Class cls = getClass(); cls != Object.class;</span>
<span class="nc" id="L614">            cls = cls.getSuperclass()) {</span>
<span class="nc" id="L615">            loc = Localizer.forPackage(cls);</span>
            try {
<span class="nc" id="L617">                return loc.getFatal(key).getMessage();</span>
<span class="nc" id="L618">            } catch (MissingResourceException mse) {</span>
            }
        }

<span class="nc bnc" id="L622" title="All 2 branches missed.">        if (fatal)</span>
<span class="nc" id="L623">            throw new MissingResourceException(key, getClass().getName(), key);</span>
<span class="nc" id="L624">        return null;</span>
    }

    ////////////////
    // To/from maps
    ////////////////

    /**
     * An internal method to retrieve properties, to support 2 public methods,
     * getAllProperties() and toProperties(boolean).
     *
     * @param storeDefaults
     *            whether or not to retrieve a property if its value is the
     *            default value.
     */
    @Override
    public Map toProperties(boolean storeDefaults) {
        // clone properties before making any modifications; we need to keep
        // the internal properties instance consistent to maintain equals and
        // hashcode contracts
        Map&lt;String, String&gt; clone;
<span class="nc bnc" id="L645" title="All 2 branches missed.">        if (_props == null)</span>
<span class="nc" id="L646">            clone = new TreeMap&lt;&gt;();</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">        else if (_props instanceof Properties)</span>
<span class="nc" id="L648">            clone = (Map) ((Properties) _props).clone();</span>
        else
<span class="nc" id="L650">            clone = new TreeMap&lt;String, String&gt;(_props);</span>

        // if no existing properties or the properties should contain entries
        // with default values, add values to properties
<span class="nc bnc" id="L654" title="All 4 branches missed.">        if (_props == null || storeDefaults) {</span>
            String str;
<span class="nc bnc" id="L656" title="All 2 branches missed.">            for (Value val : _vals) {</span>
                // NOTE: Following was removed to hide Value.INVISIBLE properties, like connectionPassword
                // if key in existing properties, we already know value is up to date
                //if (_props != null &amp;&amp; Configurations.containsProperty(val, _props) &amp;&amp; val.isVisible())
                //    continue;
<span class="nc" id="L661">                str = val.getString();</span>
<span class="nc bnc" id="L662" title="All 6 branches missed.">                if ((str != null &amp;&amp; (storeDefaults || !str.equals(val.getDefault()))))</span>
<span class="nc" id="L663">                    setValue(clone, val);</span>
<span class="nc" id="L664">            }</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">            if (_props == null)</span>
<span class="nc" id="L666">                _props = new TreeMap(clone);</span>
        }
<span class="nc" id="L668">        return clone;</span>
    }

    @Override
    public void fromProperties(Map map) {
<span class="nc bnc" id="L673" title="All 4 branches missed.">        if (map == null || map.isEmpty())</span>
<span class="nc" id="L674">            return;</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">        if (isReadOnly())</span>
<span class="nc" id="L676">            throw new IllegalStateException(_loc.get(&quot;read-only&quot;).getMessage());</span>

        // if the only previous call was to load defaults, forget them.
        // this way we preserve the original formatting of the user's props
        // instead of the defaults.  this is important for caching on
        // configuration objects
<span class="nc bnc" id="L682" title="All 2 branches missed.">        if (_globals) {</span>
<span class="nc" id="L683">            _props = null;</span>
<span class="nc" id="L684">            _globals = false;</span>
        }

        // copy the input to avoid mutation issues
<span class="nc bnc" id="L688" title="All 2 branches missed.">        if (map instanceof HashMap)</span>
<span class="nc" id="L689">            map = (Map) ((HashMap) map).clone();</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        else if (map instanceof Properties)</span>
<span class="nc" id="L691">            map = (Map) ((Properties) map).clone();</span>
        else
<span class="nc" id="L693">            map = new LinkedHashMap(map);</span>

<span class="nc" id="L695">        Map remaining = new HashMap(map);</span>
<span class="nc" id="L696">        boolean ser = true;</span>
        Object o;
<span class="nc bnc" id="L698" title="All 2 branches missed.">        for (Value val : _vals) {</span>
<span class="nc" id="L699">            o = findValue(map, val);</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">            if (o == null)</span>
<span class="nc" id="L701">                continue;</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">            if (o instanceof String) {</span>
                // OPENJPA-1830 Do not overwrite existing string values with &quot;******&quot;
<span class="nc bnc" id="L704" title="All 2 branches missed.">                if ((!Objects.equals((String) o, val.getString())) &amp;&amp;</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                        (!Objects.equals((String) o, Value.INVISIBLE)))</span>
<span class="nc" id="L706">                    val.setString((String) o);</span>
            } else {
<span class="nc" id="L708">                ser &amp;= o instanceof Serializable;</span>
<span class="nc" id="L709">                val.setObject(o);</span>
            }
<span class="nc" id="L711">            Configurations.removeProperty(val.getProperty(), remaining);</span>
<span class="nc" id="L712">        }</span>

        // convention is to point product at a resource with the
        // &lt;prefix&gt;.properties System property; remove that property so we
        // we don't warn about it
<span class="nc" id="L717">        Configurations.removeProperty(&quot;properties&quot;, remaining);</span>
<span class="nc" id="L718">        Configurations.removeProperty(&quot;Id&quot;, remaining, map);</span>

        // now warn if there are any remaining properties that there
        // is an unhandled prop, and remove the unknown properties
        Map.Entry entry;
<span class="nc bnc" id="L723" title="All 2 branches missed.">        for (Object value : remaining.entrySet()) {</span>
<span class="nc" id="L724">            entry = (Map.Entry) value;</span>
<span class="nc" id="L725">            Object key = entry.getKey();</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">            if (key != null) {</span>
<span class="nc" id="L727">                warnInvalidProperty((String) key);</span>
<span class="nc" id="L728">                map.remove(key);</span>
            }
<span class="nc" id="L730">        }</span>

        // cache properties
<span class="nc bnc" id="L733" title="All 4 branches missed.">        if (_props == null &amp;&amp; ser)</span>
<span class="nc" id="L734">            _props = map;</span>
<span class="nc" id="L735">    }</span>

    @Override
    public List&lt;String&gt; getPropertyKeys(String propertyName) {
<span class="nc" id="L739">        Value value = getValue(propertyName);</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">        return value == null ? Collections.EMPTY_LIST : value.getPropertyKeys();</span>
    }

    /**
     * Gets all known property keys.
     * The keys are harvested from the property names (including the equivalent names) of the registered values.
     * A key may be prefixed if the corresponding property name was without a prefix.
     * @see #fixPrefix(String)
     * The Values that are {@linkplain Value#makePrivate() marked private} are filtered out.
     */
    @Override
    public Set&lt;String&gt; getPropertyKeys() {
<span class="nc" id="L752">        synchronized (_supportedKeys) {</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">            if (_supportedKeys.size() == 0) {</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">                for (Value val : _vals) {</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">                    if (val.isPrivate())</span>
<span class="nc" id="L756">                        continue;</span>
<span class="nc" id="L757">                    List&lt;String&gt; keys = val.getPropertyKeys();</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">                    for (String key : keys) {</span>
<span class="nc" id="L759">                        _supportedKeys.add(fixPrefix(key));</span>
<span class="nc" id="L760">                    }</span>
<span class="nc" id="L761">                }</span>
            }
<span class="nc" id="L763">        }</span>
        //OJ2257: Return a copy of _supportedKeys as calls to this method (e.g.
        //BrokerImpl.getSupportedProperties()) may add to this set.
<span class="nc" id="L766">        return new TreeSet&lt;&gt;(_supportedKeys);</span>
    }

    /**
     * Adds a prefix &lt;code&gt;&quot;openjpa.&quot;&lt;/code&gt; to the given key, if necessary. A key is
     * considered without prefix if it starts neither of &lt;code&gt;&quot;openjpa.&quot;&lt;/code&gt;,
     * &lt;code&gt;&quot;java.&quot;&lt;/code&gt; and &lt;code&gt;&quot;javax.&quot;&lt;/code&gt;.
     */
    String fixPrefix(String key) {
<span class="nc bnc" id="L775" title="All 4 branches missed.">        return (key == null || hasKnownPrefix(key)) ? key : &quot;openjpa.&quot;+key;</span>
    }

    boolean hasKnownPrefix(String key) {
<span class="nc" id="L779">        String[] prefixes = ProductDerivations.getConfigurationPrefixes();</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">        for (String prefix : prefixes) {</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">            if (key.startsWith(prefix))</span>
<span class="nc" id="L782">                return true;</span>
        }
<span class="nc" id="L784">        return false;</span>
    }

    /**
     * Adds &lt;code&gt;o&lt;/code&gt; to &lt;code&gt;map&lt;/code&gt; under key for &lt;code&gt;val&lt;/code&gt;.
     * Use this method instead of attempting to add the value directly because
     * this will account for the property prefix.
     */
    private void setValue(Map map, Value val) {
<span class="nc" id="L793">        Object key = val.getLoadKey();</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">        if (key == null) {</span>
<span class="nc" id="L795">            List&lt;String&gt; keys = val.getPropertyKeys();</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">            for (String k : keys) {</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">                if (hasKnownPrefix(k)) {</span>
<span class="nc" id="L798">                    key = k;</span>
<span class="nc" id="L799">                    break;</span>
                }
<span class="nc" id="L801">            }</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">            if (key == null) {</span>
<span class="nc" id="L803">                key = &quot;openjpa.&quot; + val.getProperty();</span>
            }
        }
<span class="nc bnc" id="L806" title="All 4 branches missed.">        Object external = val.isHidden() ? Value.INVISIBLE :</span>
<span class="nc" id="L807">            val instanceof ObjectValue ? val.getString() : val.get();</span>
<span class="nc" id="L808">        map.put(key, external);</span>
<span class="nc" id="L809">    }</span>

    /**
     * Look up the given value, testing all available prefixes and all possible
     * property names. Detects if the given map contains multiple keys that
     * are equivalent names for the given value.
     */
    private Object findValue(Map map, Value val) {
<span class="nc" id="L817">        Object result = null;</span>
<span class="nc" id="L818">        List&lt;String&gt; partialKeys = val.getPropertyKeys();</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">        for (String partialKey : partialKeys) {</span>
<span class="nc" id="L820">            String key = ProductDerivations.getConfigurationKey(</span>
                partialKey, map);
<span class="nc bnc" id="L822" title="All 2 branches missed.">            if (map.containsKey(key)) {</span>
                // do not return immediately. Looping through all equivalent
                // property names will detect if the Map contains multiple keys
                // that are equivalent as it tries to set load key.
<span class="nc" id="L826">                val.setLoadKey(key);</span>
<span class="nc" id="L827">                result = map.get(key);</span>
            }
<span class="nc" id="L829">        }</span>
<span class="nc" id="L830">        return result;</span>
    }

    /**
     * Issue a warning that the specified property is not valid.
     */
    private void warnInvalidProperty(String propName) {
<span class="nc bnc" id="L837" title="All 2 branches missed.">        if (propName != null &amp;&amp;</span>
<span class="nc bnc" id="L838" title="All 6 branches missed.">           (propName.startsWith(&quot;java.&quot;) || propName.startsWith(&quot;javax.persistence&quot;)|| propName.startsWith(&quot;sun.&quot;)))</span>
<span class="nc" id="L839">            return;</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">        if (!isInvalidProperty(propName))</span>
<span class="nc" id="L841">            return;</span>
<span class="nc" id="L842">        Log log = getConfigurationLog();</span>
<span class="nc bnc" id="L843" title="All 4 branches missed.">        if (log == null || !log.isWarnEnabled())</span>
<span class="nc" id="L844">            return;</span>

        // try to find the closest string to the invalid property
        // so that we can provide a hint in case of a misspelling
<span class="nc" id="L848">        String closest = StringDistance.getClosestLevenshteinDistance</span>
<span class="nc" id="L849">            (propName, newPropertyList(), 15);</span>

<span class="nc bnc" id="L851" title="All 2 branches missed.">        if (closest == null)</span>
<span class="nc" id="L852">            log.warn(_loc.get(&quot;invalid-property&quot;, propName));</span>
        else
<span class="nc" id="L854">            log.warn(_loc.get(&quot;invalid-property-hint&quot;, propName, closest));</span>
<span class="nc" id="L855">    }</span>

    /**
     * Return a comprehensive list of recognized map keys.
     */
    private Collection&lt;String&gt; newPropertyList() {
<span class="nc" id="L861">        String[] prefixes = ProductDerivations.getConfigurationPrefixes();</span>
<span class="nc" id="L862">        List&lt;String&gt; l = new ArrayList&lt;&gt;(_vals.size() * prefixes.length);</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">        for(Value v : _vals) {</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">            for (String prefix : prefixes) {</span>
<span class="nc" id="L865">                l.add(prefix + &quot;.&quot; + v.getProperty());</span>
            }
<span class="nc" id="L867">        }</span>
<span class="nc" id="L868">        return l;</span>
    }

    /**
     * Returns true if the specified property name should raise a warning
     * if it is not found in the list of known properties.
     */
    protected boolean isInvalidProperty(String propName) {
        // handle warnings for openjpa.SomeString, but not for
        // openjpa.some.subpackage.SomeString, since it might be valid for some
        // specific implementation of OpenJPA
<span class="nc" id="L879">        String[] prefixes = ProductDerivations.getConfigurationPrefixes();</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">        for (String prefix : prefixes) {</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">            if (propName.toLowerCase(Locale.ENGLISH).startsWith(prefix)</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">                &amp;&amp; propName.length() &gt; prefix.length() + 1</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">                &amp;&amp; propName.indexOf('.', prefix.length()) == prefix.length()</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">                &amp;&amp; propName.indexOf('.', prefix.length() + 1) == -1</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">                &amp;&amp; &quot;openjpa&quot;.equals(prefix))</span>
<span class="nc" id="L886">                return true;</span>
        }
<span class="nc" id="L888">        return false;</span>
    }

    //////////////////////
    // Auto-configuration
    //////////////////////

    /**
     * This method loads the named resource as a properties file. It is
     * useful for auto-configuration tools so users can specify a
     * &lt;code&gt;properties&lt;/code&gt; value with the name of a resource.
     */
    public void setProperties(String resourceName) throws IOException {

<span class="nc bnc" id="L902" title="All 2 branches missed.">        if (!_deferResourceLoading) {</span>
<span class="nc" id="L903">            String anchor = null;</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">            if (resourceName.indexOf(&quot;#&quot;) != -1) {</span>
<span class="nc" id="L905">                anchor = resourceName.substring(resourceName.lastIndexOf(&quot;#&quot;) + 1);</span>
<span class="nc" id="L906">                resourceName = resourceName.substring(0, resourceName.length() - anchor.length() - 1);</span>
            }

<span class="nc" id="L909">            ProductDerivations.load(resourceName, anchor, getClass().getClassLoader()).setInto(this);</span>
        }

<span class="nc" id="L912">        _auto = resourceName;</span>
<span class="nc" id="L913">    }</span>

    /**
     * This method loads the named file as a properties file. It is
     * useful for auto-configuration tools so users can specify a
     * &lt;code&gt;propertiesFile&lt;/code&gt; value with the name of a file.
     */
    public void setPropertiesFile(File file) throws IOException {
<span class="nc" id="L921">        ProductDerivations.load(file, null, getClass().getClassLoader()).</span>
<span class="nc" id="L922">            setInto(this);</span>
<span class="nc" id="L923">        setDeferResourceLoading(false);</span>
<span class="nc" id="L924">        _auto = file.toString();</span>
<span class="nc" id="L925">    }</span>

    /**
     * Return the resource that was set via auto-configuration methods
     * {@link #setProperties} or {@link #setPropertiesFile}, or null if none.
     */
    public String getPropertiesResource() {
<span class="nc" id="L932">        return _auto;</span>
    }

    /////////////
    // Utilities
    /////////////

    /**
     * Performs an equality check based on equality of values.
     * {@link Value#equals(Object) Equality} of Values varies if the Value is
     * {@link Value#isDynamic() dynamic}.
     */
    @Override
    public boolean equals(Object other) {
<span class="nc bnc" id="L946" title="All 2 branches missed.">        if (other == this)</span>
<span class="nc" id="L947">            return true;</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">        if (other == null)</span>
<span class="nc" id="L949">            return false;</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">        if (!getClass().equals(other.getClass()))</span>
<span class="nc" id="L951">            return false;</span>

        // compare properties
<span class="nc" id="L954">        ConfigurationImpl conf = (ConfigurationImpl) other;</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">        if (_vals.size() != conf.getValues().length)</span>
<span class="nc" id="L956">        	return false;</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">        for(Value v : _vals) {</span>
<span class="nc" id="L958">            String propName = v.getProperty();</span>
<span class="nc" id="L959">        	Value thisV = this.getValue(propName);</span>
<span class="nc" id="L960">            Value thatV = conf.getValue(propName);</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">        	if (!thisV.equals(thatV)) {</span>
<span class="nc" id="L962">        		return false;</span>
        	}
<span class="nc" id="L964">        }</span>
<span class="nc" id="L965">        return true;</span>
    }

    /**
     * Computes hash code based on the hashCodes of the values.
     * {@link Value#hashCode() HashCode} of a Value varies if the Value is
     * {@link Value#isDynamic() dynamic}.
     */
    @Override
    public int hashCode() {
<span class="nc" id="L975">        int hash = 0;</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">        for(Value v : _vals) {</span>
<span class="nc" id="L977">        	hash += v.hashCode();</span>
<span class="nc" id="L978">        }</span>
<span class="nc" id="L979">        return hash;</span>
    }

    /**
     * Convert &lt;code&gt;propName&lt;/code&gt; to a lowercase-with-hyphens-style string.
     * This algorithm is only designed for mixes of uppercase and lowercase
     * letters and lone digits. A more sophisticated conversion should probably
     * be handled by a proper parser generator or regular expressions.
     */
    public static String toXMLName(String propName) {
<span class="nc bnc" id="L989" title="All 2 branches missed.">        if (propName == null)</span>
<span class="nc" id="L990">            return null;</span>
<span class="nc" id="L991">        StringBuilder buf = new StringBuilder();</span>
        char c;
<span class="nc bnc" id="L993" title="All 2 branches missed.">        for (int i = 0; i &lt; propName.length(); i++) {</span>
<span class="nc" id="L994">            c = propName.charAt(i);</span>

            // convert sequences of all-caps to downcase with dashes around
            // them. put a trailing cap that is followed by downcase into the
            // downcase word.
<span class="nc bnc" id="L999" title="All 4 branches missed.">            if (i != 0 &amp;&amp; Character.isUpperCase(c)</span>
<span class="nc bnc" id="L1000" title="All 4 branches missed.">                &amp;&amp; (Character.isLowerCase(propName.charAt(i-1))</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">                || (i &gt; 1 &amp;&amp; i &lt; propName.length() - 1</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">                &amp;&amp; Character.isUpperCase(propName.charAt(i-1))</span>
<span class="nc bnc" id="L1003" title="All 2 branches missed.">                &amp;&amp; Character.isLowerCase(propName.charAt(i+1)))))</span>
<span class="nc" id="L1004">                buf.append('-');</span>

            // surround sequences of digits with dashes.
<span class="nc bnc" id="L1007" title="All 2 branches missed.">            if (i != 0</span>
<span class="nc bnc" id="L1008" title="All 4 branches missed.">                &amp;&amp; ((!Character.isLetter(c) &amp;&amp; Character.isLetter(propName</span>
<span class="nc" id="L1009">                    .charAt(i - 1)))</span>
<span class="nc bnc" id="L1010" title="All 4 branches missed.">                || (Character.isLetter(c) &amp;&amp; !Character.isLetter(propName</span>
<span class="nc" id="L1011">                    .charAt(i - 1)))))</span>
<span class="nc" id="L1012">                buf.append('-');</span>

<span class="nc" id="L1014">            buf.append(Character.toLowerCase(c));</span>
        }
<span class="nc" id="L1016">        return buf.toString();</span>
    }

    /**
     * Implementation of the {@link Externalizable} interface to read from
     * the properties written by {@link #writeExternal}.
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void readExternal(ObjectInput in)
        throws IOException, ClassNotFoundException {
<span class="nc" id="L1027">        fromProperties((Map) in.readObject());</span>
<span class="nc" id="L1028">        _props = (Map) in.readObject();</span>
<span class="nc" id="L1029">        _globals = in.readBoolean();</span>
<span class="nc" id="L1030">    }</span>

    /**
     * Implementation of the {@link Externalizable} interface to write
     * the properties returned by {@link #toProperties}.
     */
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
<span class="nc" id="L1038">        out.writeObject(toProperties(true));</span>
<span class="nc" id="L1039">        out.writeObject(_props);</span>
<span class="nc" id="L1040">        out.writeBoolean(_globals);</span>
<span class="nc" id="L1041">    }</span>

    /**
     * Uses {@link #toProperties} and {@link #fromProperties} to clone
     * configuration.
     */
    @Override
    public Object clone() {
        try {
<span class="nc" id="L1050">            Constructor cons = getClass().getConstructor</span>
<span class="nc" id="L1051">                (new Class[]{ boolean.class });</span>
<span class="nc" id="L1052">            ConfigurationImpl clone = (ConfigurationImpl) cons.newInstance</span>
<span class="nc" id="L1053">                (new Object[]{ Boolean.FALSE });</span>
<span class="nc" id="L1054">            clone.fromProperties(toProperties(true));</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">            clone._props = (_props == null) ? null : new HashMap(_props);</span>
<span class="nc" id="L1056">            clone._globals = _globals;</span>
<span class="nc" id="L1057">            return clone;</span>
<span class="nc" id="L1058">        } catch (RuntimeException re) {</span>
<span class="nc" id="L1059">            throw re;</span>
<span class="nc" id="L1060">        } catch (Exception e) {</span>
<span class="nc" id="L1061">            throw new ParseException(e);</span>
        }
    }

    @Override
    public boolean removeValue(Value val) {
<span class="nc bnc" id="L1067" title="All 2 branches missed.">        if (!_vals.remove(val))</span>
<span class="nc" id="L1068">            return false;</span>
<span class="nc" id="L1069">        val.removeListener(this);</span>
<span class="nc" id="L1070">        return true;</span>
    }

    @Override
    public &lt;T extends Value&gt; T addValue(T val) {
<span class="nc" id="L1075">        _vals.add(val);</span>
<span class="nc" id="L1076">        val.addListener(this);</span>
<span class="nc" id="L1077">        return val;</span>
    }

    /**
     * Add the given value to the set of configuration properties.
     */
    public StringValue addString(String property) {
<span class="nc" id="L1084">        StringValue val = new StringValue(property);</span>
<span class="nc" id="L1085">        addValue(val);</span>
<span class="nc" id="L1086">        return val;</span>
    }

    /**
     * Add the given value to the set of configuration properties.
     */
    public FileValue addFile(String property) {
<span class="nc" id="L1093">        FileValue val = new FileValue(property);</span>
<span class="nc" id="L1094">        addValue(val);</span>
<span class="nc" id="L1095">        return val;</span>
    }

    /**
     * Add the given value to the set of configuration properties.
     */
    public IntValue addInt(String property) {
<span class="nc" id="L1102">        IntValue val = new IntValue(property);</span>
<span class="nc" id="L1103">        addValue(val);</span>
<span class="nc" id="L1104">        return val;</span>
    }

    /**
     * Add the given value to the set of configuration properties.
     */
    public DoubleValue addDouble(String property) {
<span class="nc" id="L1111">        DoubleValue val = new DoubleValue(property);</span>
<span class="nc" id="L1112">        addValue(val);</span>
<span class="nc" id="L1113">        return val;</span>
    }

    /**
     * Add the given value to the set of configuration properties.
     */
    public BooleanValue addBoolean(String property) {
<span class="nc" id="L1120">        BooleanValue val = new BooleanValue(property);</span>
<span class="nc" id="L1121">        addValue(val);</span>
<span class="nc" id="L1122">        val.setDefault(&quot;false&quot;);</span>
<span class="nc" id="L1123">        return val;</span>
    }

    /**
     * Add the given value to the set of configuration properties.
     */
    public StringListValue addStringList(String property) {
<span class="nc" id="L1130">        StringListValue val = new StringListValue(property);</span>
<span class="nc" id="L1131">        addValue(val);</span>
<span class="nc" id="L1132">        return val;</span>
    }

    /**
     * Add the given value to the set of configuration properties.
     */
    public ObjectValue addObject(String property) {
<span class="nc" id="L1139">        ObjectValue val = new ObjectValue(property);</span>
<span class="nc" id="L1140">        addValue(val);</span>
<span class="nc" id="L1141">        return val;</span>
    }

    /**
     * Add the given value to the set of configuration properties.
     */
    public PluginValue addPlugin(String property, boolean singleton) {
<span class="nc" id="L1148">        PluginValue val = new PluginValue(property, singleton);</span>
<span class="nc" id="L1149">        addValue(val);</span>
<span class="nc" id="L1150">        return val;</span>
    }

    /**
     * Add the given value to the set of configuration properties.
     */
    public PluginListValue addPluginList(String property) {
<span class="nc" id="L1157">        PluginListValue val = new PluginListValue(property);</span>
<span class="nc" id="L1158">        addValue(val);</span>
<span class="nc" id="L1159">        return val;</span>
    }

    @Override
    public ClassLoader getUserClassLoader() {
<span class="nc" id="L1164">    	return _userCL;</span>
    }

    @Override
    public void setUserClassLoader(ClassLoader cl) {
<span class="nc" id="L1169">    	_userCL = cl;</span>
<span class="nc" id="L1170">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>